<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving
and Interchange DTD v1.2 20190208//EN" "JATS-archivearticle1.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" dtd-version="1.2" article-type="other">
  <front>
    <article-meta>
      <title-group>
        <article-title>Testing Welfare Improvability</article-title>
      </title-group>
      <contrib-group>
        <contrib contrib-type="author" corresp="yes">
          <name>
            <surname>Paul</surname>
            <given-names>Joseph R.</given-names>
          </name>
          <string-name>Joseph R. Paul</string-name>
          <email>steve@curvenote.com</email>
          <role vocab="https://credit.niso.org" vocab-term="writing – original draft" vocab-term-identifier="https://credit.niso.org/contributor-roles/writing-original-draft/">writing</role>
          <xref ref-type="aff" rid="aff-1">a</xref>
          <xref ref-type="corresp" rid="cor-1">*</xref>
        </contrib>
      </contrib-group>
      <aff id="aff-1">
        <institution-wrap>
          <institution>Heriot-Watt University</institution>
        </institution-wrap>
      </aff>
      <author-notes>
        <corresp id="cor-1">steve@curvenote.com</corresp>
      </author-notes>
      <history/>
      <abstract>
        <p>Here is a placeholder for the abstract.</p>
      </abstract>
      <kwd-group kwd-group-type="author">
        <kwd>Empirical Welfare Maximisation</kwd>
        <kwd>Algorithmic Deicison Making</kwd>
        <kwd>Algorithm Discrimination</kwd>
      </kwd-group>
    </article-meta>
  </front>
  <body>
    <sec id="introduction">
      <title>Introduction</title>
      <p>Potential Names - Comparing Algorithmic Impacts with Doubly-Robust
  Estimation - Statistical Inference for Comparing Treatment Assignment
  Algorithms - Making Informed Choices: A Framework for Evaluating the
  Impact of Competing Algorithms - Statistical Inference for Comparing
  Treatment Assignment Algorithms</p>
    </sec>
    <sec id="old-policy-evaluation">
      <title>(old) Policy Evaluation</title>
      <p>The use of algorithmic decision-making systems is becoming
  increasingly pervasive across many areas of society. There is a
  growing critical need for robust methods to evaluate their performance
  and impacts on those they make decisions about. From healthcare and
  criminal justice to financial services and education, these systems
  are increasingly shaping outcomes that profoundly affect individual
  lives and social structures. While there is great potential for
  algorithms to enhance efficiency and fairness, their use raises
  significant concerns about their impacts on well-being. However, the
  potential of algorithms to enhance efficiency and fairness should
  instil optimism about their future impact.</p>
      <p>Algorithms have emerged as powerful and valuable tools for
  addressing complex economic decision problems, offering substantial
  benefits across various domains. Ludwig, Mullainathan, and Rambachan,
  in their study on “The Unreasonable Effectiveness of Algorithms,”
  argue that they can also provide a “free lunch in terms of public
  spending. For instance, in the criminal justice system, an algorithm
  applied to pretrial release decisions in New York City demonstrated
  the potential to reduce pretrial detentions by up to
  <inline-formula><alternatives><tex-math><![CDATA[40\%]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mn>40</mml:mn><mml:mi>%</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
  Without increasing failure rates (REF). In healthcare, an algorithmic
  approach to diagnosing heart attacks could potentially reduce
  unnecessary stress tests and catheterisations, leading to significant
  cost savings, potentially billions in Medicare costs annually.</p>
      <p>Given the promise, we need robust methods to help us decide
  <italic>which</italic> algorithm to use.</p>
      <p>The power of algorithms lies in their ability to extract signals
  from complex datasets, often outperforming human judgement in ranking
  and prediction tasks. This capability allows for more efficient
  allocation of resources and more accurate decision-making in various
  economic contexts. In education, Bergman et al. (2023) found that an
  algorithm for college course placement increased enrollments in
  college-level classes without compromising pass rates while also
  reducing disparities across racial and ethnic groups. In workplace
  safety regulation, Johnson et al. (2023) demonstrated that an
  algorithm could better predict which work sites will likely have
  future injuries, potentially preventing thousands of severe injuries
  and saving hundreds of millions of dollars in lost income.</p>
      <p>However, it is crucial to note that the effectiveness of algorithms
  has its challenges. These promising results should not lead to
  immediate large-scale implementation but encourage further research
  and development in algorithmic solutions to policy problems. The need
  for this research is urgent and of utmost importance. Key challenges
  remain, such as understanding how decision-makers will respond to
  algorithmic tools in practice (Albright REF), addressing potential
  data drift over time, ensuring algorithms generalise across different
  contexts, and accurately assessing the impact of policies. This paper
  aims to contribute to addressing that last problem.</p>
      <p>Recent years have witnessed substantial progress in developing
  frameworks for assessing the welfare implications of algorithmic
  decisions, mainly through the lens of treatment effects. This includes
  the empirical welfare maximisation literature, including the seminal
  work by and , which established rigorous foundations for policy
  learning and demonstrating the possibility of deriving optimal
  treatment assignment policies that maximise welfare under various
  constraints. The purpose of empirical welfare maximisation is to
  leverage treatment heterogeneity to maximise welfare using an
  algorithmic decision policy at an almost
  <inline-formula><alternatives><tex-math><![CDATA[1/\sqrt{n}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mn>1</mml:mn><mml:mi>/</mml:mi><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt></mml:mrow></mml:math></alternatives></inline-formula>
  convergence rate. Athey and Wager’s work, rooted in the theory of
  semiparametric efficiency estimation , has opened new avenues for
  understanding and improving algorithmic decision-making processes.
  However, the existing literature on policy learning often focuses on
  asymptotic optimality within simplified policy classes, prioritizing
  theoretical guarantees over their practical applicability. While these
  contributions are invaluable, there remains a pressing need for more
  pragmatic approaches that can navigate the complexities of real-world
  algorithmic systems. This research aims to bridge the gap by proposing
  a novel framework for assessing welfare impacts of algorithmic
  treatment decisions and to help practitioners implement and find
  decision policies. There is concern around the finite-sample
  performance of some of this methods, with limited guarantees of
  optimally in finite samples.</p>
      <p>Our approach introduces a testing procedure for welfare
  improvability that evaluates a status quo algorithm or policy against
  a class of proposed algorithmic policies. This method offers several
  key advantages over existing methods proposed in the empirical welfare
  maximization literature. First, it allows for greater flexibility in
  the policy class selection, with almost no constraints placed on the
  set of allowed policies a priori. This can accommodate large and
  complex state-of-the-art algorithms such as deep neural networks or
  large ensembles that may outperform simpler, analytically tractable
  policy sets in practice. Second, it yields interpretable results, in
  terms of treatment effects, that can be readily understood by
  policymakers, legal experts, and other non-technical stakeholders.
  Third, it has potential applications in legal and ethical contexts,
  providing a framework for demonstrating the absence of discriminatory
  practices or the impossibility of Pareto improvements in welfare for
  specific subgroups such as men and women.</p>
      <p>Given sufficiently fast convergence of estimation of the nucciance
  parameters in the estimation of average treatment effects, we show
  that the proposed bootstrap procedure is consistent in its estimation
  of average welfare. This approach allows for the welfare ranking of
  policies (). The decision theoretic idea of optimising some population
  decision function using a sample analogue is known as the Empirical
  Risk Minimising principal in classification and statistical learning
  (Vapnik, 1998).</p>
      <p>By adopting this methodology, we take a more nuanced view of
  algorithmic decision-making than traditional empirical welfare
  maximization approaches. Rather than focus solely on identifying the
  optimal policy within a restricted class, we provide a framework for
  evaluating and comparing complex algorithmic systems in terms of their
  welfare impacts. This shift in perspective opens up new possibilities
  for understanding and improving algorithmic decision-making in
  real-world contexts. As algorithmic systems become increasingly
  influential and critical in decision-making processes, the ability to
  rigorously assess their welfare impacts becomes paramount. This
  approach provides a practical tool for policymakers, legal
  professionals, researchers, and ethicists to evaluate the fairness and
  efficacy of algorithmic decisions. Moreover, it offers a means to
  detect and address potential biases or inefficiencies in existing
  systems, contributing to the development of more equitable and
  efficient algorithmic policies. UK Government’s Data Ethics Framework
  which asks practitioners to perform a self-assessment of their
  transparency, fairness, and accountability [18].</p>
      <p>Furthermore, it has been argued that using complex models are often
  preferable to simple models [Simplicity Creates Inequity: Implications
  for Fairness, Stereotypes, and Interpretability]. The authors show
  that for every simple prediction function, there exists a more complex
  function that is strictly more equitable and more efficient. (Can the
  statement be made that for every simple policy class, there exists a
  more favorable complex policy class. What does learnability have to
  say about comparisons across policy classes?).</p>
      <p>In the sections that follow, we first review the literature on
  policy evaluation, building on the seminal work on semi-parametric
  efficiency by . We then propose our testing procedure and show that we
  efficiently and unbiasedly estimate differences in welfare of
  different algorithmic decision-making policies and show the
  convergence of our bootstrap estimation procedure. Wed Monte Carlo
  studies results, showing how the method is used in practice, and
  finally, we apply this method to the real-world setting of [TO BE
  FILLED IN LATER].</p>
      <p>By offering a pragmatic yet rigorous approach to assessing the
  welfare impacts of algorithmic decisions, this research aims to
  contribute to the ongoing dialogue about the role and use of
  algorithms. The tools presented here will help develop a more
  transparent, accountable, and welfare-enhancing use of algorithmic
  decision policies.</p>
      <p>We assume that we have independent and identically distributed
  samples <inline-formula><alternatives><tex-math><![CDATA[X_{i}, Y^*_{i}, Y_{i}, D_{i}, Z_{i}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msubsup><mml:mi>Y</mml:mi><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:mo>,</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>D</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>Z</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>,
  where <inline-formula><alternatives><tex-math><![CDATA[Y^*_{i} \in \mathbb{R}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:msubsup><mml:mi>Y</mml:mi><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:mo>∈</mml:mo><mml:mi>ℝ</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
  is an outcome we try to predict, <inline-formula><alternatives><tex-math><![CDATA[D_{i} \in \mathcal{D}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:msub><mml:mi>D</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi>𝒟</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
  is the observed treatment assignment, <inline-formula><alternatives><tex-math><![CDATA[X_{i} \in \mathcal{X}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi>𝒳</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
  are a subject’s features, and <inline-formula><alternatives><tex-math><![CDATA[Z_{i}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mi>Z</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
  is an (optional) instrument, and <inline-formula><alternatives><tex-math><![CDATA[Y_{i}\in\mathbb{R}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:msub><mml:mi>Y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi>ℝ</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
  is interpreted as the utility resulting from the intervention. If
  <inline-formula><alternatives><tex-math><![CDATA[D_{i}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mi>D</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
  is conditionally exogenous, then <inline-formula><alternatives><tex-math><![CDATA[Z_{i}=D_{i}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:msub><mml:mi>Z</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>D</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>.
  It might also be the case that our target variable is equal to the
  measured utility <inline-formula><alternatives><tex-math><![CDATA[Y^*_{i} = Y_{i}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:msubsup><mml:mi>Y</mml:mi><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>.</p>
      <p>A decision-making algorithm is <inline-formula><alternatives><tex-math><![CDATA[a \in \mathcal{A}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>a</mml:mi><mml:mo>∈</mml:mo><mml:mi>𝒜</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
  is a mapping from a subject’s features to a decision
  <inline-formula><alternatives><tex-math><![CDATA[a: \mathcal{X} \to \mathcal{D}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>a</mml:mi><mml:mo>:</mml:mo><mml:mi>𝒳</mml:mi><mml:mo>→</mml:mo><mml:mi>𝒟</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>.</p>
      <p>We can define the causal effect of an intervention in terms of
  potential outcomes, where <inline-formula><alternatives><tex-math><![CDATA[U_{i}(d)]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:msub><mml:mi>U</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  correspond to the utility of subjects <inline-formula><alternatives><tex-math><![CDATA[i]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>i</mml:mi></mml:math></alternatives></inline-formula>
  under treatment <inline-formula><alternatives><tex-math><![CDATA[d \in \mathcal{D}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>d</mml:mi><mml:mo>∈</mml:mo><mml:mi>𝒟</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>.</p>
      <p>When our treatment <inline-formula><alternatives><tex-math><![CDATA[D_{i}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mi>D</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
  is binary, the utility under the algorithm
  <inline-formula><alternatives><tex-math><![CDATA[a]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>a</mml:mi></mml:math></alternatives></inline-formula>
  is measured against no-treatment <disp-formula><alternatives><tex-math><![CDATA[
  V(a) = \mathbf{E}[Y_{i}(a(X_{i})) - Y_{i}(0)]
  ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:mi>V</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>𝐄</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>a</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></disp-formula></p>
      <p>In the policy learning literature, the policy is then usually
  evaluated as the regret of the algorithm relative to the best
  algorithm in class <inline-formula><alternatives><tex-math><![CDATA[a \in \mathcal{A'}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>a</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mi>𝒜</mml:mi><mml:mi mathvariant="script">′</mml:mi></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  given by: <disp-formula><alternatives><tex-math><![CDATA[
  R(a) = \max_{a'} \{  V(a') \in \mathcal{A'} \} - V(a).
  ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:mi>R</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:munder><mml:mo>max</mml:mo><mml:mrow><mml:mi>a</mml:mi><mml:mi>′</mml:mi></mml:mrow></mml:munder><mml:mo stretchy="false" form="prefix">{</mml:mo><mml:mi>V</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>a</mml:mi><mml:mi>′</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>∈</mml:mo><mml:mrow><mml:mi>𝒜</mml:mi><mml:mi mathvariant="script">′</mml:mi></mml:mrow><mml:mo stretchy="false" form="postfix">}</mml:mo><mml:mo>−</mml:mo><mml:mi>V</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mi>.</mml:mi></mml:mrow></mml:math></alternatives></disp-formula>
  <inline-formula><alternatives><tex-math><![CDATA[\mathcal{A'}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>𝒜</mml:mi><mml:mi mathvariant="script">′</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
  is usually constrained to be a limited class of functions, such as
  linear decision rules or shallow decision trees. This is done to
  contain the VC dimension of the policy class to make asymptotic regret
  guarantees tractable. In this research, no such restrictions are
  placed on the class of allowed potential decision algorithms.</p>
      <p>As shown by Kitagawa and Tetenov (2018), if
  <inline-formula><alternatives><tex-math><![CDATA[D_{i}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mi>D</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
  is exogenous with known treatment propensities and a suitable class of
  policies, inverse propensity weighting can be used to derive a policy
  <inline-formula><alternatives><tex-math><![CDATA[\hat{a}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mover><mml:mi>a</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover></mml:math></alternatives></inline-formula>
  whose regret <inline-formula><alternatives><tex-math><![CDATA[R(\hat{a})]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>R</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mover><mml:mi>a</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  decays with <inline-formula><alternatives><tex-math><![CDATA[\frac{1}{\sqrt{ n }}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mfrac><mml:mn>1</mml:mn><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt></mml:mfrac></mml:math></alternatives></inline-formula>,
  with <disp-formula><alternatives><tex-math><![CDATA[
  \hat{a} = \arg\max \left\{  \frac{1}{n}\sum_{i=1}^n  \frac{1(\{ D_{i} = a(X_{i}) \})Y^*_{i}}{P[D_{i} = a(X_{i}) \mid X_{i}]} : a \in \mathcal{A'} \right\}.
  ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:mover><mml:mi>a</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mo>arg</mml:mo><mml:mo>max</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">{</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>n</mml:mi></mml:mfrac><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:mfrac><mml:mrow><mml:mn>1</mml:mn><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mo stretchy="false" form="prefix">{</mml:mo><mml:msub><mml:mi>D</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>a</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="false" form="postfix">}</mml:mo><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:msubsup><mml:mi>Y</mml:mi><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msubsup></mml:mrow><mml:mrow><mml:mi>P</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:msub><mml:mi>D</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>a</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>∣</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:mrow></mml:mfrac><mml:mo>:</mml:mo><mml:mi>a</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mi>𝒜</mml:mi><mml:mi mathvariant="script">′</mml:mi></mml:mrow><mml:mo stretchy="true" form="postfix">}</mml:mo></mml:mrow><mml:mi>.</mml:mi></mml:mrow></mml:math></alternatives></disp-formula></p>
      <p>Athey and Wager (2020) extend this to cases where treatment
  propensities are unknown and may need to be identified from
  operational data.</p>
      <p>In the case of a continuous intervention, the utility of an
  infinitesimal intervention is given by <disp-formula><alternatives><tex-math><![CDATA[
  V(a) =  \left[ \frac{d}{d \nu} \mathbf{E}[Y^*_{i}(D_{i} + \nu a(X_{i}))] \right]_{\nu=0},
  ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:mi>V</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mfrac><mml:mi>d</mml:mi><mml:mrow><mml:mi>d</mml:mi><mml:mi>ν</mml:mi></mml:mrow></mml:mfrac><mml:mi>𝐄</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:msubsup><mml:mi>Y</mml:mi><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>D</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:mi>ν</mml:mi><mml:mi>a</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mrow><mml:mi>ν</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:mrow></mml:math></alternatives></disp-formula>
  with regret defined similarly. An example of a continuous intervention
  would be price interventions.</p>
      <p>In the case of using observational data, as opposed to using data
  generated from an experiment, we need to make assumptions about the
  data-generating process that allow for identification and estimation
  of expected utility <inline-formula><alternatives><tex-math><![CDATA[V(a)]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>V</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>.</p>
      <p>The empirical welfare maximisation literature relies on controlling
  the size of the policy class <inline-formula><alternatives><tex-math><![CDATA[\mathcal{A}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>𝒜</mml:mi></mml:math></alternatives></inline-formula>,
  to make an estimation of a “best in class” policy realistic. This work
  takes a more pragmatic view of the problem in that we are more
  interested in testing if we are able to produce a decision-making
  algorithm that results in higher welfare without potentially achieving
  a “best in class” algorithm or with specific regret guarantees. This
  allows for the use of more “powerful” black-box machine learning
  algorithms to be used in these settings for which formal regret
  guarantees don’t exist or are hard to prove.</p>
    </sec>
    <sec id="related-literature">
      <title>Related Literature</title>
      <p>This paper can be related to two distinct fields of study. The
  first is policy learning, which has gained interest from
  econometricians, statisticians, and computer scientists. In this line
  of literature, statistical methods have been developed to find the
  optimal policy, often from a pre-defined class of allowed policies. We
  can further divide these methods into model-based methods and
  direct-search methods.</p>
      <p>Belonging to model-based approaches, from the computer science
  literature, we have Q-learning (Qian and Murphy, 2011) and A-learning
  (Shi et al., 2018), which both estimate a conditional expectations
  function (or contrast function) and then determine the optimal policy
  from these predictions. A short coming of this approach is that it
  relies heavily on correct functional form assumptions.</p>
      <p>Among direct search methods, outcome weighting (Zhao et al., 2012)
  attempts to learn the optimal policy non-parametrically using an
  inverse probability weighting estimator (IPWE). %%What economic jargon
  is used here?%% However, it is well known that there is the potential
  for instability caused by extreme propensity scores and model
  specification.</p>
      <p>To increase stability, some methods use the augmented IPWE (Zhang
  et al., 2012a,b; Zhao et al., 2019; Athey and Wager, 2021; Pan and
  Zhao, 2021), which has the double-robustness property. Athey and
  Wager’s (2021)’s seminal method comes with minimal optimal regret
  guarantees under suitable regularity conditions of the estimators.
  These methods come with strong theoretical guarantees but still suffer
  extreme weights. This problem is made more server when we only have
  small sample sizes.</p>
      <p>Similar to Athey and Wager (2021), we propose using generalised
  double machine learning to estimate the causal effects of a decision
  function, using cross-fitting and classical estimators or flexible ML
  for the estimation of nuisance function.</p>
      <disp-quote>
        <p>Similar phenomena have been discussed in both policy learning and
    causal inference literature (e.g., Zhao et al., 2019; Wu et al.,
    2022). From (Matching-Based Policy Learning)</p>
      </disp-quote>
      <p>The evaluation of treatment assignment rules has a long history in
  economics. Classic examples in economics include enrolment in
  government welfare programs (Dehejia, 2005), job training programs
  (Black et al., 2003; Frölich, 2008) and judge sentencing decisions
  (Bushway and Smith, 2007). This has often taken the for of the minimax
  regret, an approach pioneered by Manski (2004).</p>
      <p>A short coming with the literature on optimal statistical decision
  rules is that rules are undetermined in complex setting such as
  including capisity or fairness constraints.</p>
      <p>This research is also motivated by fair machine learning /
  automated decision-making.</p>
    </sec>
    <sec id="treatment-effect-evaluation">
      <title>Treatment Effect Evaluation</title>
    </sec>
    <sec id="notation">
      <title>Notation</title>
      <p>Let <inline-formula><alternatives><tex-math><![CDATA[W]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>W</mml:mi></mml:math></alternatives></inline-formula>
  represent a measure of welfare, <inline-formula><alternatives><tex-math><![CDATA[Y]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>Y</mml:mi></mml:math></alternatives></inline-formula>
  signify a given outcome, <inline-formula><alternatives><tex-math><![CDATA[X]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>X</mml:mi></mml:math></alternatives></inline-formula>
  denote a set of covariates and <inline-formula><alternatives><tex-math><![CDATA[Z]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>Z</mml:mi></mml:math></alternatives></inline-formula>
  indicate a set of potential instruments, and a treatment variable
  <inline-formula><alternatives><tex-math><![CDATA[D]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>D</mml:mi></mml:math></alternatives></inline-formula>.
  Formally, define <inline-formula><alternatives><tex-math><![CDATA[Z]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>Z</mml:mi></mml:math></alternatives></inline-formula>
  such that <inline-formula><alternatives><tex-math><![CDATA[Z := (W, Y, X, Z, D)]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>Z</mml:mi><mml:mo>:=</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>W</mml:mi><mml:mo>,</mml:mo><mml:mi>Y</mml:mi><mml:mo>,</mml:mo><mml:mi>X</mml:mi><mml:mo>,</mml:mo><mml:mi>Z</mml:mi><mml:mo>,</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>.</p>
    </sec>
    <sec id="average-treatment-effect-estimation">
      <title>Average Treatment Effect Estimation</title>
      <p>To define welfare for evaluating algorithm decisions, we introduce
  potential outcomes. In the binary treatment case, the realized outcome
  is given by <disp-formula><alternatives><tex-math><![CDATA[
  W = D W(1) + (1-D)W(0).
  ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:mi>W</mml:mi><mml:mo>=</mml:mo><mml:mi>D</mml:mi><mml:mi>W</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mi>W</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mi>.</mml:mi></mml:mrow></mml:math></alternatives></disp-formula>
  As is common analysis of statistical decision rules, we can evaluate
  the performance of an algorithm can be evaluated based on the
  distribution of outcomes induced by the algorithm.</p>
      <p>To start, we consider estimating the treatment effect in the
  partially linear regression model <disp-formula><alternatives><tex-math><![CDATA[
  W = \theta_{0}D + m(X) + e
  ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:mi>W</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mi>D</mml:mi><mml:mo>+</mml:mo><mml:mi>m</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>e</mml:mi></mml:mrow></mml:math></alternatives></disp-formula>
  &gt; I don’t think this is quite correct.</p>
      <p>Treatment assignment problems are related to the estimation of
  conditonaly average treatement effects. Assuming conditonal
  independence of treatment, we have <disp-formula><alternatives><tex-math><![CDATA[
  W_{i} \mid T_{i}=t, X_{i}=x \sim F_{t}(\cdot\mid x).
  ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:msub><mml:mi>W</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∣</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>x</mml:mi><mml:mo>∼</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>⋅</mml:mi><mml:mo>∣</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mi>.</mml:mi></mml:mrow></mml:math></alternatives></disp-formula></p>
      <p>Under utilitarian welfare (with <inline-formula><alternatives><tex-math><![CDATA[Y]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>Y</mml:mi></mml:math></alternatives></inline-formula>
  normalised to utilis),, the welfare of a treatment algorithm
  <inline-formula><alternatives><tex-math><![CDATA[a]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>a</mml:mi></mml:math></alternatives></inline-formula>
  is given by the below definition.</p>
      <p>In this paper, we propose using
  (<xref alt="chernozhukovLocallyRobustSemiparametric2022?" rid="ref-chernozhukovLocallyRobustSemiparametric2022" ref-type="bibr"><bold>chernozhukovLocallyRobustSemiparametric2022?</bold></xref>)’s
  method, which is a general GMM framework for estimating treatment
  effect-like parameters based on debiased machine learning. In the
  basic algorithm, the inference is based upon a method of moments
  estimator for some low dimensional parameter, such as the ATE, based
  upon the empirical analogue of the moment condition
  <disp-formula><alternatives><tex-math><![CDATA[
  \mathbb{E}[\psi(Z; \theta_{0}, \eta)] =0
  ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:mi>𝔼</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>ψ</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>Z</mml:mi><mml:mo>;</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mi>η</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></alternatives></disp-formula>
  <inline-formula><alternatives><tex-math><![CDATA[\psi]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>ψ</mml:mi></mml:math></alternatives></inline-formula>
  is the score, <inline-formula><alternatives><tex-math><![CDATA[\theta_{0}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mi>θ</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:math></alternatives></inline-formula>
  denotes the true value of the parameter of interest and
  <inline-formula><alternatives><tex-math><![CDATA[\eta]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>η</mml:mi></mml:math></alternatives></inline-formula>
  being the nuisance paramters with true values
  <inline-formula><alternatives><tex-math><![CDATA[\eta_{0}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mi>η</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:math></alternatives></inline-formula>.
  The expectation is taken over <inline-formula><alternatives><tex-math><![CDATA[Z]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>Z</mml:mi></mml:math></alternatives></inline-formula>.</p>
      <p>The score function has the important property that
  <disp-formula><alternatives><tex-math><![CDATA[
  M(\theta, \eta) = \mathbb{E}[\psi(Z, \theta, \eta)]
  ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:mi>M</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>θ</mml:mi><mml:mo>,</mml:mo><mml:mi>η</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>𝔼</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>ψ</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>Z</mml:mi><mml:mo>,</mml:mo><mml:mi>θ</mml:mi><mml:mo>,</mml:mo><mml:mi>η</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></disp-formula>
  identifies <inline-formula><alternatives><tex-math><![CDATA[\theta_{0}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mi>θ</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:math></alternatives></inline-formula>
  when <inline-formula><alternatives><tex-math><![CDATA[\eta=\eta_{0}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>η</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mi>η</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>
  (<inline-formula><alternatives><tex-math><![CDATA[M(\theta, \eta_{0}) =0 \iff \theta=\theta_{0}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>M</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>θ</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>η</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>⇔</mml:mo><mml:mi>θ</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>),
  as well as having the Neyman orthogonality condition
  <disp-formula><alternatives><tex-math><![CDATA[
  \partial_{\eta}M(\theta_{0}, \eta) \bigg|_{\eta=\eta_{0}} =0,
  ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:msub><mml:mi>∂</mml:mi><mml:mi>η</mml:mi></mml:msub><mml:mi>M</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mi>η</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:msub><mml:mo minsize="2.4" maxsize="2.4" stretchy="false" form="prefix">|</mml:mo><mml:mrow><mml:mi>η</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mi>η</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo></mml:mrow></mml:math></alternatives></disp-formula>
  where <inline-formula><alternatives><tex-math><![CDATA[\partial_{\eta}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mi>∂</mml:mi><mml:mi>η</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
  detnoes the pathwise or Gateaux derivative operator. This amounts to
  the scoring function being locally insensitive to perturbations around
  the true value of the nuisance parameters.</p>
      <p>Validity of the approach depends on defining an appropriate score
  function that satisfies the above condition, with some being proposed
  below.</p>
      <sec id="neyman-orthogoal-scores-for-the-linear-regression-model">
        <title>Neyman Orthogoal scores for the linear regression
    model</title>
        <p>A suitable score for the paritally linear regression model is
    given by <disp-formula><alternatives><tex-math><![CDATA[
    \psi (Z; \theta, \eta) = \{ W - \ell(X) - \theta(D - m(X) \}(D - m(X))
    ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:mi>ψ</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>Z</mml:mi><mml:mo>;</mml:mo><mml:mi>θ</mml:mi><mml:mo>,</mml:mo><mml:mi>η</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mo stretchy="false" form="prefix">{</mml:mo><mml:mi>W</mml:mi><mml:mo>−</mml:mo><mml:mo>ℓ</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mi>θ</mml:mi><mml:mo stretchy="false" form="prefix">(</mml:mo><mml:mi>D</mml:mi><mml:mo>−</mml:mo><mml:mi>m</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="false" form="postfix">}</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>D</mml:mi><mml:mo>−</mml:mo><mml:mi>m</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></disp-formula>
    where <inline-formula><alternatives><tex-math><![CDATA[\eta = (\ell, m)]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>η</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mo>ℓ</mml:mo><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>,
    with true value <inline-formula><alternatives><tex-math><![CDATA[\eta_{0} = (\ell_{0}, m_{0})]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:msub><mml:mi>η</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mo>ℓ</mml:mo><mml:mn>0</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>m</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>.
    Here <inline-formula><alternatives><tex-math><![CDATA[\ell]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mo>ℓ</mml:mo></mml:math></alternatives></inline-formula>
    and <inline-formula><alternatives><tex-math><![CDATA[m]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>m</mml:mi></mml:math></alternatives></inline-formula>
    are square-integrable functions mapping the support of
    <inline-formula><alternatives><tex-math><![CDATA[X]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>X</mml:mi></mml:math></alternatives></inline-formula>
    to <inline-formula><alternatives><tex-math><![CDATA[\mathbb{R}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>ℝ</mml:mi></mml:math></alternatives></inline-formula>,
    whose true values are the following conditional expecatation
    functions <disp-formula><alternatives><tex-math><![CDATA[
    \ell_{0}(X) = \mathbb{E}(W \mid X), ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ m_{0}(X) = \mathbb{E}[D \mid X].
    ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:msub><mml:mo>ℓ</mml:mo><mml:mn>0</mml:mn></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>𝔼</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>W</mml:mi><mml:mo>∣</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mspace width="0.222em"/><mml:mspace width="0.222em"/><mml:mspace width="0.222em"/><mml:mspace width="0.222em"/><mml:mspace width="0.222em"/><mml:mspace width="0.222em"/><mml:mspace width="0.222em"/><mml:mspace width="0.222em"/><mml:mspace width="0.222em"/><mml:mspace width="0.222em"/><mml:mspace width="0.222em"/><mml:msub><mml:mi>m</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>𝔼</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>D</mml:mi><mml:mo>∣</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mi>.</mml:mi></mml:mrow></mml:math></alternatives></disp-formula></p>
      </sec>
      <sec id="interactive-regression-model">
        <title>Interactive Regression Model</title>
        <p>For estimation of the average treatment effect in the interactive
    reegression model, we can use the following score function
    <disp-formula><alternatives><tex-math><![CDATA[
    \psi(Z; \theta, \eta) := (g(1, x) - g(0, x)) + H(D, X)(W-g(D, X)) - \theta,
    ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:mi>ψ</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>Z</mml:mi><mml:mo>;</mml:mo><mml:mi>θ</mml:mi><mml:mo>,</mml:mo><mml:mi>η</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>:=</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>g</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mi>g</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>H</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>D</mml:mi><mml:mo>,</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>W</mml:mi><mml:mo>−</mml:mo><mml:mi>g</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>D</mml:mi><mml:mo>,</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mi>θ</mml:mi><mml:mo>,</mml:mo></mml:mrow></mml:math></alternatives></disp-formula>
    where <disp-formula><alternatives><tex-math><![CDATA[
    H(D, X) := \frac{D}{m(X)} - \frac{1-D}{1-m(X)}.
    ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:mi>H</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>D</mml:mi><mml:mo>,</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>:=</mml:mo><mml:mfrac><mml:mi>D</mml:mi><mml:mrow><mml:mi>m</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:mfrac><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>m</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:mfrac><mml:mi>.</mml:mi></mml:mrow></mml:math></alternatives></disp-formula>
    This similar to the well-known doubly-robust estimator. It is known
    as doubly robust due to having the property that either the
    propentisy score or the outcome needs to be properly modelled.</p>
        <p>Here <inline-formula><alternatives><tex-math><![CDATA[g]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>g</mml:mi></mml:math></alternatives></inline-formula>
    is a square-integratable function mapping the support of
    <inline-formula><alternatives><tex-math><![CDATA[(D, X)]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>D</mml:mi><mml:mo>,</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>
    to <inline-formula><alternatives><tex-math><![CDATA[\mathbb{R}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>ℝ</mml:mi></mml:math></alternatives></inline-formula>,
    and <inline-formula><alternatives><tex-math><![CDATA[m]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>m</mml:mi></mml:math></alternatives></inline-formula>
    maps the support of <inline-formula><alternatives><tex-math><![CDATA[X]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>X</mml:mi></mml:math></alternatives></inline-formula>
    to <inline-formula><alternatives><tex-math><![CDATA[(\epsilon, 1-\epsilon)]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>ϵ</mml:mi><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>ϵ</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>,
    where <inline-formula><alternatives><tex-math><![CDATA[\epsilon \in (0, 0.5)]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>ϵ</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0.5</mml:mn><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>.
    The true values are given by <disp-formula><alternatives><tex-math><![CDATA[
    g_{0}(X) = \mathbb{E}(W \mid D, X), ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ m_{0}(X) = \mathbb{E}[D \mid X].
    ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:msub><mml:mi>g</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>𝔼</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>W</mml:mi><mml:mo>∣</mml:mo><mml:mi>D</mml:mi><mml:mo>,</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mspace width="0.222em"/><mml:mspace width="0.222em"/><mml:mspace width="0.222em"/><mml:mspace width="0.222em"/><mml:mspace width="0.222em"/><mml:mspace width="0.222em"/><mml:mspace width="0.222em"/><mml:mspace width="0.222em"/><mml:mspace width="0.222em"/><mml:mspace width="0.222em"/><mml:mspace width="0.222em"/><mml:msub><mml:mi>m</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>𝔼</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>D</mml:mi><mml:mo>∣</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mi>.</mml:mi></mml:mrow></mml:math></alternatives></disp-formula></p>
      </sec>
      <sec id="assumption-learners">
        <title>Assumption Learners</title>
        <p>To get consistent estimates, we need to assume sufficiently
    quality of the models that we use. For estimated nuciance components
    <inline-formula><alternatives><tex-math><![CDATA[\eta]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>η</mml:mi></mml:math></alternatives></inline-formula>,
    sufficient condition being <disp-formula><alternatives><tex-math><![CDATA[
    \sqrt[4]{n } \mid\mid \hat{\eta} - \eta_{0} \mid\mid \approx 0.
    ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:mroot><mml:mi>n</mml:mi><mml:mn>4</mml:mn></mml:mroot><mml:mo>∣</mml:mo><mml:mi>∣</mml:mi><mml:mover><mml:mi>η</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mo>−</mml:mo><mml:msub><mml:mi>η</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>∣</mml:mo><mml:mi>∣</mml:mi><mml:mo>≈</mml:mo><mml:mn>0</mml:mn><mml:mi>.</mml:mi></mml:mrow></mml:math></alternatives></disp-formula>
    Choice of the base estimators depends on the situation at hand. For
    example, believing the data to be sparce, we might choose to use
    LASSO with a dictionary of transformations on
    <inline-formula><alternatives><tex-math><![CDATA[X]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>X</mml:mi></mml:math></alternatives></inline-formula>.
    How we choose learners is still an active area of research with not
    much said about choosing the theoretically best learner. That is why
    we advocate ensembles or what has been called “super-learning”.</p>
        <p>The performance of the ensemble is theoretically no worse that
    the best performing model in used our base learners. We can
    therefore combine powerful machine learning estimators, which may be
    have good finite sample performance, with various non-parametric
    estimators (which are known to satisfy the conditions
    asymptotically).</p>
        <p>Under the following an appropriate score function, assumptions
    (X) on the convergence of the learners and the use of
    sample-splitting, the approach works for estimating average
    treatment effects.</p>
      </sec>
    </sec>
    <sec id="the-double-machine-learning-algorithm">
      <title>The Double machine learning algorithm</title>
      <p>Under the above assumpitons, assume we have a sample
  <inline-formula><alternatives><tex-math><![CDATA[\{ Z_{i} \}_{i=1}^n]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mo stretchy="false" form="prefix">{</mml:mo><mml:msub><mml:mi>Z</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msubsup><mml:mo stretchy="false" form="postfix">}</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula>
  modelled as i.i.d coipies of random variable
  <inline-formula><alternatives><tex-math><![CDATA[Z]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>Z</mml:mi></mml:math></alternatives></inline-formula>,
  hows law is determined by the probability measure
  <inline-formula><alternatives><tex-math><![CDATA[P]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>P</mml:mi></mml:math></alternatives></inline-formula>.
  The DML algorithm dives unbiased estimates of the paramter
  <inline-formula><alternatives><tex-math><![CDATA[\theta]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>θ</mml:mi></mml:math></alternatives></inline-formula>.</p>
      <p><bold>DML Algorithm</bold> Inputs: <inline-formula><alternatives><tex-math><![CDATA[\{ Z_{i} \}_{i=1}^n]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mo stretchy="false" form="prefix">{</mml:mo><mml:msub><mml:mi>Z</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msubsup><mml:mo stretchy="false" form="postfix">}</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula>,
  the Neyman orthogonal score/moment function
  <inline-formula><alternatives><tex-math><![CDATA[\psi (Z, \theta, \eta)]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>ψ</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>Z</mml:mi><mml:mo>,</mml:mo><mml:mi>θ</mml:mi><mml:mo>,</mml:mo><mml:mi>η</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  that identifies the paramter of interest, and estimation methods
  <inline-formula><alternatives><tex-math><![CDATA[\mathcal{A}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>𝒜</mml:mi></mml:math></alternatives></inline-formula>
  for <inline-formula><alternatives><tex-math><![CDATA[\eta]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>η</mml:mi></mml:math></alternatives></inline-formula>.</p>
      <p>Take a <inline-formula><alternatives><tex-math><![CDATA[K-fold]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>K</mml:mi><mml:mo>−</mml:mo><mml:mi>f</mml:mi><mml:mi>o</mml:mi><mml:mi>l</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
  random partition <inline-formula><alternatives><tex-math><![CDATA[(I_{k})_{k=1}^K]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msubsup><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>I</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>K</mml:mi></mml:msubsup></mml:math></alternatives></inline-formula>
  of observation indicies <inline-formula><alternatives><tex-math><![CDATA[\{ 1, \dots, n \}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mo stretchy="false" form="prefix">{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>…</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false" form="postfix">}</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>
  such that each fold is approximiatly the same size For
  <inline-formula><alternatives><tex-math><![CDATA[k \in \{  1, \dots, K \}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>k</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false" form="prefix">{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>…</mml:mi><mml:mo>,</mml:mo><mml:mi>K</mml:mi><mml:mo stretchy="false" form="postfix">}</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>
  do <inline-formula><alternatives><tex-math><![CDATA[\hat{\eta}_{[k]} = \mathcal{A}((X_{i})_{i \not\in I_{k}})]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:msub><mml:mover><mml:mi>η</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>𝒜</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>∉</mml:mo><mml:msub><mml:mi>I</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  end do Let <inline-formula><alternatives><tex-math><![CDATA[k(i) = \{ k: i \in I_{k} \}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>k</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mo stretchy="false" form="prefix">{</mml:mo><mml:mi>k</mml:mi><mml:mo>:</mml:mo><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi>I</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false" form="postfix">}</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>
  <inline-formula><alternatives><tex-math><![CDATA[\hat{M}(\theta, \hat{\eta}) = \frac{1}{n}\sum_{i=1}^n \psi(Z_{i}, \theta, \hat{\eta}_{{k(i)}})]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mover><mml:mi>M</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>θ</mml:mi><mml:mo>,</mml:mo><mml:mover><mml:mi>η</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>n</mml:mi></mml:mfrac><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:mi>ψ</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>Z</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>θ</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mover><mml:mi>η</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mrow><mml:mi>k</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  (The moment equation estimator) <inline-formula><alternatives><tex-math><![CDATA[\hat{\theta} =]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mover><mml:mi>θ</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mo>=</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>
  solution of <inline-formula><alternatives><tex-math><![CDATA[\hat{M}(\hat{\theta}, \hat{\eta}) = 0]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mover><mml:mi>M</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mover><mml:mi>θ</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover><mml:mi>η</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></alternatives></inline-formula></p>
      <p>The asymptotic variance is given by <disp-formula><alternatives><tex-math><![CDATA[\hat{V} = \frac{1}{n} \sum_{{i=1}}^n [\hat{\varrho}(Z_{i})\hat{\varrho}(Z_{i})'] - \frac{1}{n} \sum_{i=1}^n[\hat{\varrho}(Z_{i})] \frac{1}{n} \sum_{i=1}^n[\hat{\varrho}(Z_{i})]']]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:mover><mml:mi>V</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>n</mml:mi></mml:mfrac><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mover><mml:mo>𝜚</mml:mo><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>Z</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mover><mml:mo>𝜚</mml:mo><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>Z</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mi>′</mml:mi><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>n</mml:mi></mml:mfrac><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mover><mml:mo>𝜚</mml:mo><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>Z</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mi>n</mml:mi></mml:mfrac><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mover><mml:mo>𝜚</mml:mo><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>Z</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:math></alternatives></disp-formula>
  where <inline-formula><alternatives><tex-math><![CDATA[\hat{\varrho}(Z_{i}) = - \hat{J}_{0}^{-1} \psi (Z_{i}, \hat{\theta}, \hat{\eta}_{[k(i)]})]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mover><mml:mo>𝜚</mml:mo><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>Z</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>−</mml:mi><mml:msubsup><mml:mover><mml:mi>J</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mn>0</mml:mn><mml:mrow><mml:mi>−</mml:mi><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mi>ψ</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>Z</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mover><mml:mi>θ</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:msub><mml:mover><mml:mi>η</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>k</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  and <inline-formula><alternatives><tex-math><![CDATA[\hat{J}_{0} = \partial_{0} \frac{1}{n} \sum_{i=1}^n \psi(Z_{i}, \hat{\theta}, \hat{\eta}_{[k(i)]})]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:msub><mml:mover><mml:mi>J</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>∂</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mfrac><mml:mn>1</mml:mn><mml:mi>n</mml:mi></mml:mfrac><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:mi>ψ</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>Z</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mover><mml:mi>θ</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:msub><mml:mover><mml:mi>η</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>k</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>.</p>
      <p>Chernozhukov et al (book) recommend using 4-5 for a medium sized
  data-set. For smaller data-sets, we may choose to do more splits.</p>
      <p>Under strong identification assumption, we identify the
  <inline-formula><alternatives><tex-math><![CDATA[\theta]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>θ</mml:mi></mml:math></alternatives></inline-formula>.
  That is we have <inline-formula><alternatives><tex-math><![CDATA[M(\theta, \eta_{0}) = 0 \iff \theta=\theta_{0}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>M</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>θ</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>η</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>⇔</mml:mo><mml:mi>θ</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>
  and that <inline-formula><alternatives><tex-math><![CDATA[J_{0}:= \partial _\theta \mathbb{E}[\psi(Z; \theta_{0}, \eta_{0})]]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:msub><mml:mi>J</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>:=</mml:mo><mml:msub><mml:mi>∂</mml:mi><mml:mi>θ</mml:mi></mml:msub><mml:mi>𝔼</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>ψ</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>Z</mml:mi><mml:mo>;</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>η</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  has singular values that are bounded away from zero. This method also
  has the beneficial quality of being Neyman orthogonal.</p>
      <p>In most settings, our nuisance parameters will be a regression
  function <disp-formula><alternatives><tex-math><![CDATA[
  \eta_{m} = \mathbb{E}[V_{m} \mid X_{m}], ~m \in \{ 1, \dots, M \}.
  ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:msub><mml:mi>η</mml:mi><mml:mi>m</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>𝔼</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:msub><mml:mi>V</mml:mi><mml:mi>m</mml:mi></mml:msub><mml:mo>∣</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>m</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mspace width="0.222em"/><mml:mi>m</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false" form="prefix">{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>…</mml:mi><mml:mo>,</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false" form="postfix">}</mml:mo><mml:mi>.</mml:mi></mml:mrow></mml:math></alternatives></disp-formula>
  Chernozhukov (Book) recommend the following method for choosing the
  parameter. Select <inline-formula><alternatives><tex-math><![CDATA[J]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>J</mml:mi></mml:math></alternatives></inline-formula>
  different poteintal ML or statistical estimators - For each
  <inline-formula><alternatives><tex-math><![CDATA[j \in \{ 1, \dots, J \}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false" form="prefix">{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>…</mml:mi><mml:mo>,</mml:mo><mml:mi>J</mml:mi><mml:mo stretchy="false" form="postfix">}</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>,
  compute cross-fitted MSPE <disp-formula><alternatives><tex-math><![CDATA[
  \mathbb{E}_{n} [\hat{V}_{mj}^2]
  ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:msub><mml:mi>𝔼</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:msubsup><mml:mover><mml:mi>V</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mrow><mml:mi>m</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msubsup><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></disp-formula>
  - Select model <inline-formula><alternatives><tex-math><![CDATA[j]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>j</mml:mi></mml:math></alternatives></inline-formula>
  which has the lowest MPSE - Use method <inline-formula><alternatives><tex-math><![CDATA[\hat{j}_{m}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mover><mml:mi>j</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mi>m</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
  as the learer of <inline-formula><alternatives><tex-math><![CDATA[\eta_{m}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mi>η</mml:mi><mml:mi>m</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
  in the generic DML algorithm.</p>
      <p>While note giving us direct individual treatment effects, we can
  use this on our way to building estimates of the utility of an
  algorithm.</p>
    </sec>
    <sec id="from-average-to-conditional-treatment-effects">
      <title>From Average to Conditional Treatment Effects</title>
      <p>We express the CATE as the conditional expectation of an unbiased
  signal <disp-formula><alternatives><tex-math><![CDATA[
  \tau_{0}(X) = \mathbb{E}[Y(\eta_{0}) \mid X],
  ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:msub><mml:mi>τ</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>𝔼</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>Y</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>η</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>∣</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:math></alternatives></disp-formula>
  where the unbasied signal takes the from <disp-formula><alternatives><tex-math><![CDATA[
  Y(\eta) = H(\mu)(Y-g(D, Z)) + g(1, Z) - g(0, Z),
  ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:mi>Y</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>η</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>H</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>μ</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>Y</mml:mi><mml:mo>−</mml:mo><mml:mi>g</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>D</mml:mi><mml:mo>,</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>g</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mi>g</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:math></alternatives></disp-formula>
  with nuisance parameters <inline-formula><alternatives><tex-math><![CDATA[\eta  :=(\mu, \eta)]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>η</mml:mi><mml:mo>:=</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>μ</mml:mi><mml:mo>,</mml:mo><mml:mi>η</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  and <disp-formula><alternatives><tex-math><![CDATA[
  H(\mu) := \frac{D}{\mu(Z)} - \frac{1-D}{1-\mu(Z)},
  ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:mi>H</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>μ</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>:=</mml:mo><mml:mfrac><mml:mi>D</mml:mi><mml:mrow><mml:mi>μ</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:mfrac><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>μ</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:mfrac><mml:mo>,</mml:mo></mml:mrow></mml:math></alternatives></disp-formula>
  and</p>
      <p><disp-formula><alternatives><tex-math><![CDATA[
  \mu_{0}(Z) := P(D=1 \mid Z), g_{0}(D, Z) := \mathbb{E}[Y \mid Z, D].
  ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:msub><mml:mi>μ</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>:=</mml:mo><mml:mi>P</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>D</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>∣</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>D</mml:mi><mml:mo>,</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>:=</mml:mo><mml:mi>𝔼</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>Y</mml:mi><mml:mo>∣</mml:mo><mml:mi>Z</mml:mi><mml:mo>,</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mi>.</mml:mi></mml:mrow></mml:math></alternatives></disp-formula>
  &gt; This is from chapter 14 CausalML Book. pg 378</p>
      <p>We can then form (I think) our individual score as
  <disp-formula><alternatives><tex-math><![CDATA[
  \begin{aligned}
  Y_{i}(\hat{\eta}) &= Y_{i}(\hat{\eta}_{[k]}) \\
  &= H_{i}(Y_{i} - \hat{g}_{[k]}(D_{i}, Z_{i})) + \hat{g}_{[k]}(1, Z_{i}) - \hat{g}_{[k]}(0, Z_{i})
  \end{aligned}
  ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mtable><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:msub><mml:mi>Y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mover><mml:mi>η</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mo>=</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mover><mml:mi>η</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right" style="text-align: right"/><mml:mtd columnalign="left" style="text-align: left"><mml:mo>=</mml:mo><mml:msub><mml:mi>H</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mover><mml:mi>g</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>D</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>Z</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:msub><mml:mover><mml:mi>g</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mi>Z</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mover><mml:mi>g</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mi>Z</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula>
  where <inline-formula><alternatives><tex-math><![CDATA[H_{i}(\mu) := \frac{D}{\hat{\mu}_{[k]}(Z)} - \frac{1-D}{1-\hat{\mu}_{[k]}(Z)}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:msub><mml:mi>H</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>μ</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>:=</mml:mo><mml:mfrac><mml:mi>D</mml:mi><mml:mrow><mml:msub><mml:mover><mml:mi>μ</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:mfrac><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mover><mml:mi>μ</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:mfrac></mml:mrow></mml:math></alternatives></inline-formula>.</p>
      <disp-quote>
        <p>Where does this leave me. I knew that it should already be
    unbiased. And if it wasn’t then It wouldn’t work anyway. What I
    think is a bit of a disapointnment is that the asympototics are
    already worked out. But there is lots to say about asympototics</p>
      </disp-quote>
      <disp-quote>
        <p>It is unlikely that the finite sample properties are tractable.
    Could the bootstrap thus prove to be better in finite settings.</p>
      </disp-quote>
      <p>You are referred to <bold>X</bold> for a detailed treatment.</p>
      <p>A probabilistic decision algorithm <inline-formula><alternatives><tex-math><![CDATA[a(X) \in [0,1]]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>a</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>∈</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  returns the probability of making a positive decision (e.g. to treat
  or not to treat). As part of assessing the quality of an algorithm, we
  want to create inference on the value of algorithm
  <inline-formula><alternatives><tex-math><![CDATA[a]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>a</mml:mi></mml:math></alternatives></inline-formula>.</p>
      <p>Given an algorithm <inline-formula><alternatives><tex-math><![CDATA[a]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>a</mml:mi></mml:math></alternatives></inline-formula>,
  I define the value of the algorithm as the average value if we follow
  <inline-formula><alternatives><tex-math><![CDATA[a]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>a</mml:mi></mml:math></alternatives></inline-formula>’s
  decisions vs treating no one in our population:
  <disp-formula><alternatives><tex-math><![CDATA[
  \begin{aligned}
  V(a) :&= \mathbb{E}[a(X) Y(1) + (1-a(X))Y(0)] - \mathbb{E}(Y(0)) \\
  &= \mathbb{E}[a(X)(Y(1) - Y(0))] \\
  &= \mathbb{E}[a(X)\tau_{0}(X)]
  \end{aligned}
  ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mtable><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:mi>V</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>:</mml:mo></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mo>=</mml:mo><mml:mi>𝔼</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>a</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mi>Y</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>a</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mi>Y</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mi>𝔼</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>Y</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right" style="text-align: right"/><mml:mtd columnalign="left" style="text-align: left"><mml:mo>=</mml:mo><mml:mi>𝔼</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>a</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>Y</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mi>Y</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right" style="text-align: right"/><mml:mtd columnalign="left" style="text-align: left"><mml:mo>=</mml:mo><mml:mi>𝔼</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>a</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:msub><mml:mi>τ</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
      <p>As we have shown, the CATE is identified by
  <inline-formula><alternatives><tex-math><![CDATA[\mathbb{E}[Y(\eta_{0} \mid X)]]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>𝔼</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>Y</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>η</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>∣</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  (Theorem 5.2.1). This implies our value of our algorithm is given by
  <disp-formula><alternatives><tex-math><![CDATA[
  V(a) := \mathbb{E}[a(X)\mathbb{E}[Y(\eta_{0} \mid X)]] = \mathbb{E}[a(X)Y(\eta_{0})].
  ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:mi>V</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>:=</mml:mo><mml:mi>𝔼</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>a</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mi>𝔼</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>Y</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>η</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>∣</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>𝔼</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>a</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mi>Y</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>η</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mi>.</mml:mi></mml:mrow></mml:math></alternatives></disp-formula>
  I will next present an algorithm for estimating this, and then show
  that this provides an biased estimate of the value of the
  algorithm.</p>
      <p>Theorem (10.4)</p>
      <p>We next show how our proposed bootstrap procedure can be used to
  efficiently compare the effect of different algorithmic policies.</p>
    </sec>
    <sec id="proposed-approach">
      <title>Proposed Approach</title>
    </sec>
    <sec id="outline-of-testing-procedure">
      <title>Outline of testing procedure</title>
      <p>We have access to an independent and identically distributed set of
  variables <inline-formula><alternatives><tex-math><![CDATA[\{ (X_{i}, W_{i}, Y_{i}, G_{i}, Z_{i}, D_{i})_{i=1}^n \}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mo stretchy="false" form="prefix">{</mml:mo><mml:msubsup><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>W</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>G</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>Z</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>D</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:mo stretchy="false" form="postfix">}</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>
  drawn from an unknown distribution <inline-formula><alternatives><tex-math><![CDATA[\mathbf{P}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>𝐏</mml:mi></mml:math></alternatives></inline-formula>.
  An algorithm <inline-formula><alternatives><tex-math><![CDATA[a: \mathcal{X} \to \mathcal{D}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>a</mml:mi><mml:mo>:</mml:mo><mml:mi>𝒳</mml:mi><mml:mo>→</mml:mo><mml:mi>𝒟</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
  maps covariate vectors to a decision in set
  <inline-formula><alternatives><tex-math><![CDATA[\mathcal{D}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>𝒟</mml:mi></mml:math></alternatives></inline-formula>.
  We define the value of an algorithm as <disp-formula><alternatives><tex-math><![CDATA[
  \hat{V}(a) = \frac{1}{n}\sum_{i=1}^n a(X_{i}) \hat{W}(\hat{\eta})
  ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:mover><mml:mi>V</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>n</mml:mi></mml:mfrac><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:mi>a</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mover><mml:mi>W</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mover><mml:mi>η</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></disp-formula>
  <bold>Definition</bold> (Welfare Improvability). Fix some
  <inline-formula><alternatives><tex-math><![CDATA[\delta \in \mathbb{R}_{+}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>δ</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>.
  We say an algorithm <inline-formula><alternatives><tex-math><![CDATA[a_{1} \in \mathcal{A}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>∈</mml:mo><mml:mi>𝒜</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
  consititutes a <inline-formula><alternatives><tex-math><![CDATA[\delta]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>δ</mml:mi></mml:math></alternatives></inline-formula>-welfare
  improvement if and only if <disp-formula><alternatives><tex-math><![CDATA[
  \frac{V(a_{1})}{V(a_{0})} \geq 1 + \delta
  ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>V</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>V</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:mfrac><mml:mo>≥</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mi>δ</mml:mi></mml:mrow></mml:math></alternatives></disp-formula></p>
      <p>In the testing procedure, the null hypothesis is given by
  <disp-formula><alternatives><tex-math><![CDATA[
  H_{0}: \text{Algorithm $a_{0}$ is not $\delta$}\text{-improvable within class } \mathcal{A}
  ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:msub><mml:mi>H</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>:</mml:mo><mml:mrow><mml:mrow><mml:mtext mathvariant="normal">Algorithm </mml:mtext><mml:mspace width="0.333em"/></mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mrow><mml:mspace width="0.333em"/><mml:mtext mathvariant="normal"> is not </mml:mtext><mml:mspace width="0.333em"/></mml:mrow><mml:mi>δ</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="normal">-improvable within class </mml:mtext><mml:mspace width="0.333em"/></mml:mrow><mml:mi>𝒜</mml:mi></mml:mrow></mml:math></alternatives></disp-formula>
  with the alternative being that such an algorithm exists.</p>
      <p>The analysis must then define a selection rule or mapping from data
  samples to an algorithm in <inline-formula><alternatives><tex-math><![CDATA[\mathcal{A}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>𝒜</mml:mi></mml:math></alternatives></inline-formula>:
  <disp-formula><alternatives><tex-math><![CDATA[
  \rho: \mathcal{S} \to \mathcal{A},
  ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>:</mml:mo><mml:mi>𝒮</mml:mi><mml:mo>→</mml:mo><mml:mi>𝒜</mml:mi><mml:mo>,</mml:mo></mml:mrow></mml:math></alternatives></disp-formula>
  where <inline-formula><alternatives><tex-math><![CDATA[\mathcal{S} = \bigcup_{m \geq 1}S_{m} = \bigcup_{m\geq 1}(\mathcal{X, Y}^m)]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>𝒮</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mo>⋃</mml:mo><mml:mrow><mml:mi>m</mml:mi><mml:mo>≥</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mi>S</mml:mi><mml:mi>m</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mo>⋃</mml:mo><mml:mrow><mml:mi>m</mml:mi><mml:mo>≥</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msup><mml:mrow><mml:mi>𝒳</mml:mi><mml:mo mathvariant="script">,</mml:mo><mml:mi>𝒴</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:msup><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  is the set of all finite samples of observations.</p>
      <p>A sample-splitting procedure is then used to test for welfare
  improvability. First, choose the number of splits
  <inline-formula><alternatives><tex-math><![CDATA[K]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>K</mml:mi></mml:math></alternatives></inline-formula>,
  and for each split in the data, choose the size of a hold-out set
  <inline-formula><alternatives><tex-math><![CDATA[1-\beta]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>β</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>.
  We then perform the following three steps For
  <inline-formula><alternatives><tex-math><![CDATA[k = 1, \dots, K]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>…</mml:mi><mml:mo>,</mml:mo><mml:mi>K</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
  1. Split the sample into train and test sets. The training sample
  <inline-formula><alternatives><tex-math><![CDATA[S_{train}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mi>S</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mi>r</mml:mi><mml:mi>a</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>
  has <inline-formula><alternatives><tex-math><![CDATA[m=\lfloor \beta n \rfloor]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false" form="prefix">⌊</mml:mo><mml:mi>β</mml:mi><mml:mi>n</mml:mi><mml:mo stretchy="false" form="postfix">⌋</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>
  observations selected uniformly at radnom.
  <inline-formula><alternatives><tex-math><![CDATA[S_{test}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mi>S</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>
  contains the remaining observations. 2. Find a candiate algorithm
  using <inline-formula><alternatives><tex-math><![CDATA[S_{train}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mi>S</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mi>r</mml:mi><mml:mi>a</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>.
  Using the selection rule, produce a candidate algorithm
  <inline-formula><alternatives><tex-math><![CDATA[\hat{a}_{1k} = \rho(S_{train})]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:msub><mml:mover><mml:mi>a</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mrow><mml:mn>1</mml:mn><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>ρ</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mi>r</mml:mi><mml:mi>a</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>.
  3. Test whether <inline-formula><alternatives><tex-math><![CDATA[\hat{a}_{1k}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mover><mml:mi>a</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mrow><mml:mn>1</mml:mn><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>
  constitutes a <inline-formula><alternatives><tex-math><![CDATA[\delta]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>δ</mml:mi></mml:math></alternatives></inline-formula>-welfare
  improvement over <inline-formula><alternatives><tex-math><![CDATA[a_{0}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mi>a</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:math></alternatives></inline-formula>.</p>
    </sec>
    <sec id="test">
      <title>Test</title>
      <p>Samples, with mean values <inline-formula><alternatives><tex-math><![CDATA[\mu_{1}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mi>μ</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></alternatives></inline-formula>
  and <inline-formula><alternatives><tex-math><![CDATA[\mu_{2}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mi>μ</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:math></alternatives></inline-formula>.
  Under the null hypothesis <disp-formula><alternatives><tex-math><![CDATA[
  H_{0}: \mu_{1} \leq \mu_{2}
  ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:msub><mml:mi>H</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>:</mml:mo><mml:msub><mml:mi>μ</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>≤</mml:mo><mml:msub><mml:mi>μ</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></alternatives></disp-formula>
  and <disp-formula><alternatives><tex-math><![CDATA[
  H_{1}: \mu_{1}>\mu_{2}
  ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:msub><mml:mi>H</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>:</mml:mo><mml:msub><mml:mi>μ</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>&gt;</mml:mo><mml:msub><mml:mi>μ</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></alternatives></disp-formula>
  We take the pooled sample <inline-formula><alternatives><tex-math><![CDATA[\mathbf{v} = (V(a_{1}), V(a_{2}))]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>𝐯</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>V</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mi>V</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>.
  Our bootstrap sample is taken from the pooled sample
  <inline-formula><alternatives><tex-math><![CDATA[\mathbf{v^*} = (V_{1}', V_{2}')]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:msup><mml:mi>𝐯</mml:mi><mml:mo mathvariant="bold">*</mml:mo></mml:msup><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>V</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mi>′</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>V</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mi>′</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
  by sampling from <inline-formula><alternatives><tex-math><![CDATA[\mathbf{v}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>𝐯</mml:mi></mml:math></alternatives></inline-formula>
  with replacement.</p>
      <p>We generate the p-value by generating independent bootstrap samples
  <inline-formula><alternatives><tex-math><![CDATA[\mathbf{v^*}^{1}, \dots, \mathbf{v^*}^{B}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:msup><mml:msup><mml:mi>𝐯</mml:mi><mml:mo mathvariant="bold">*</mml:mo></mml:msup><mml:mn>1</mml:mn></mml:msup><mml:mo>,</mml:mo><mml:mi>…</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:msup><mml:mi>𝐯</mml:mi><mml:mo mathvariant="bold">*</mml:mo></mml:msup><mml:mi>B</mml:mi></mml:msup></mml:mrow></mml:math></alternatives></inline-formula>
  with the p-value calculated as <disp-formula><alternatives><tex-math><![CDATA[
  \hat{p} = \frac{1}{B} \sum_{b=1}^B I\{ T(\mathbf{v^*}^{b}) \leq T(\mathbf{v}) \}
  ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:mover><mml:mi>p</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>B</mml:mi></mml:mfrac><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>b</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>B</mml:mi></mml:munderover><mml:mi>I</mml:mi><mml:mo stretchy="false" form="prefix">{</mml:mo><mml:mi>T</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msup><mml:msup><mml:mi>𝐯</mml:mi><mml:mo mathvariant="bold">*</mml:mo></mml:msup><mml:mi>b</mml:mi></mml:msup><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>≤</mml:mo><mml:mi>T</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>𝐯</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="false" form="postfix">}</mml:mo></mml:mrow></mml:math></alternatives></disp-formula></p>
      <sec id="test-asymptotic">
        <title>Test Asymptotic</title>
        <p>With our ideal bootstrap, as <inline-formula><alternatives><tex-math><![CDATA[n \to \infty]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>n</mml:mi><mml:mo>→</mml:mo><mml:mi>∞</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>:
    <disp-formula><alternatives><tex-math><![CDATA[
    \sqrt{ n }(T(\hat{P}) - T({P})) \to^d F
    ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>T</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mover><mml:mi>P</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mi>T</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:msup><mml:mo>→</mml:mo><mml:mi>d</mml:mi></mml:msup><mml:mi>F</mml:mi></mml:mrow></mml:math></alternatives></disp-formula>
    Main asymptotic justification of the bootstrap, conditional on
    <inline-formula><alternatives><tex-math><![CDATA[X_{i}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></alternatives></inline-formula>:
    <disp-formula><alternatives><tex-math><![CDATA[
    \sqrt{ n }(T(P^*) - T(\hat{P})) \to^d F
    ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>T</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msup><mml:mi>P</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mi>T</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mover><mml:mi>P</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:msup><mml:mo>→</mml:mo><mml:mi>d</mml:mi></mml:msup><mml:mi>F</mml:mi></mml:mrow></mml:math></alternatives></disp-formula></p>
        <sec id="conditional-clt-for-the-mean">
          <title>Conditional CLT for the mean</title>
          <p>Let <inline-formula><alternatives><tex-math><![CDATA[X_{i}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
      be iid random vectors with mean <inline-formula><alternatives><tex-math><![CDATA[\mu]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>μ</mml:mi></mml:math></alternatives></inline-formula>
      and covariance <inline-formula><alternatives><tex-math><![CDATA[\Sigma]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>Σ</mml:mi></mml:math></alternatives></inline-formula>.</p>
          <disp-quote>
            <p>Delta method If <inline-formula><alternatives><tex-math><![CDATA[\phi]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>ϕ</mml:mi></mml:math></alternatives></inline-formula>
        is continuously differentiable, then
        <inline-formula><alternatives><tex-math><![CDATA[\sqrt{ n }(\hat{\theta}_{n} - \theta) \to^d T]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mover><mml:mi>θ</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mi>θ</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:msup><mml:mo>→</mml:mo><mml:mi>d</mml:mi></mml:msup><mml:mi>T</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
        and <inline-formula><alternatives><tex-math><![CDATA[\sqrt{ n }(\hat{\theta}_{n}^* - \hat{\theta}) \to^d T]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msubsup><mml:mover><mml:mi>θ</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mi>n</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:mo>−</mml:mo><mml:mover><mml:mi>θ</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:msup><mml:mo>→</mml:mo><mml:mi>d</mml:mi></mml:msup><mml:mi>T</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
        conditionally, then <inline-formula><alternatives><tex-math><![CDATA[\sqrt{ n }(\phi(\hat{\theta}_{n}) - \phi(\theta)) \to^d \phi'(T)]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>ϕ</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mover><mml:mi>θ</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mi>n</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mi>ϕ</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>θ</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:msup><mml:mo>→</mml:mo><mml:mi>d</mml:mi></mml:msup><mml:mi>ϕ</mml:mi><mml:mi>′</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
        and <inline-formula><alternatives><tex-math><![CDATA[\sqrt{ n }(\phi(\hat{\theta}_{n}^*) - \phi(\hat{\theta})) \to^d \phi'(T)]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>ϕ</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msubsup><mml:mover><mml:mi>θ</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mi>n</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mi>ϕ</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mover><mml:mi>θ</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:msup><mml:mo>→</mml:mo><mml:mi>d</mml:mi></mml:msup><mml:mi>ϕ</mml:mi><mml:mi>′</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
        conditionally.</p>
          </disp-quote>
          <p>Though Edgeworth expansion (a refinement of the central limit
      theorem) that the bootstrap has a faster convergence rate than
      simple normal approximations.</p>
        </sec>
        <sec id="iterated-bootstrap">
          <title>Iterated Bootstrap</title>
          <p>If chosen correctly, the iterated bootstrap can have higher
      rate of convergence than the non-iterated bootstrap.</p>
          <p>Double Bootstrap Idea: Use an iterated version of the bootstrap
      to correct the p-value (the bootstrap does not guarantee that the
      p-value will be distributed uniformly under the null, although it
      should). Let <inline-formula><alternatives><tex-math><![CDATA[p]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>p</mml:mi></mml:math></alternatives></inline-formula>
      be the p-value based on <inline-formula><alternatives><tex-math><![CDATA[\hat{P}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mover><mml:mi>P</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover></mml:math></alternatives></inline-formula>.
      Let <inline-formula><alternatives><tex-math><![CDATA[p^*]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msup><mml:mi>p</mml:mi><mml:mo>*</mml:mo></mml:msup></mml:math></alternatives></inline-formula>
      be the random variable obtained by resampling from
      <inline-formula><alternatives><tex-math><![CDATA[\hat{P}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mover><mml:mi>P</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover></mml:math></alternatives></inline-formula>.
      We get the adjusted p-value from <disp-formula><alternatives><tex-math><![CDATA[
      p_{adj} = P^*(p^* \leq p \mid \hat{P}).
      ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mi>d</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mi>P</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msup><mml:mi>p</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo>≤</mml:mo><mml:mi>p</mml:mi><mml:mo>∣</mml:mo><mml:mover><mml:mi>P</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mi>.</mml:mi></mml:mrow></mml:math></alternatives></disp-formula>
      <bold>Set-up</bold> Generate <inline-formula><alternatives><tex-math><![CDATA[X^*_{1}, \dots, X^*_{n}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:msubsup><mml:mi>X</mml:mi><mml:mn>1</mml:mn><mml:mo>*</mml:mo></mml:msubsup><mml:mo>,</mml:mo><mml:mi>…</mml:mi><mml:mo>,</mml:mo><mml:msubsup><mml:mi>X</mml:mi><mml:mi>n</mml:mi><mml:mo>*</mml:mo></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula>
      from the fitted null distribution <inline-formula><alternatives><tex-math><![CDATA[\hat{P}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mover><mml:mi>P</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover></mml:math></alternatives></inline-formula>
      (I think this is the pooled sample), calculating the test
      statistic <inline-formula><alternatives><tex-math><![CDATA[t_{r}^*]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msubsup><mml:mi>t</mml:mi><mml:mi>r</mml:mi><mml:mo>*</mml:mo></mml:msubsup></mml:math></alternatives></inline-formula>.
      We then fit the null distribution to
      <inline-formula><alternatives><tex-math><![CDATA[X^*_{1}, \dots, X^*_{n}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:msubsup><mml:mi>X</mml:mi><mml:mn>1</mml:mn><mml:mo>*</mml:mo></mml:msubsup><mml:mo>,</mml:mo><mml:mi>…</mml:mi><mml:mo>,</mml:mo><mml:msubsup><mml:mi>X</mml:mi><mml:mi>n</mml:mi><mml:mo>*</mml:mo></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula>
      obtaining <inline-formula><alternatives><tex-math><![CDATA[\hat{P}_{r}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mover><mml:mi>P</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mi>r</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
      for <inline-formula><alternatives><tex-math><![CDATA[m = 1,\dots, M]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>…</mml:mi><mml:mo>,</mml:mo><mml:mi>M</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>:
      - Generate <inline-formula><alternatives><tex-math><![CDATA[X^{* *}_{1}, \dots, X^{* *}_{n}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:msubsup><mml:mi>X</mml:mi><mml:mn>1</mml:mn><mml:mrow><mml:mi>*</mml:mi><mml:mo>*</mml:mo></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:mi>…</mml:mi><mml:mo>,</mml:mo><mml:msubsup><mml:mi>X</mml:mi><mml:mi>n</mml:mi><mml:mrow><mml:mi>*</mml:mi><mml:mo>*</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula>
      from <inline-formula><alternatives><tex-math><![CDATA[\hat{P}_{r}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mover><mml:mi>P</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mi>r</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
      - Calculate the test statistic <inline-formula><alternatives><tex-math><![CDATA[t^{* *}_{{rm}}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msubsup><mml:mi>t</mml:mi><mml:mrow><mml:mi>r</mml:mi><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mi>*</mml:mi><mml:mo>*</mml:mo></mml:mrow></mml:msubsup></mml:math></alternatives></inline-formula>
      from them Let <inline-formula><alternatives><tex-math><![CDATA[p^*_{r} = \frac{1 + I\{ t^{* *}_{rm} \geq t_{r}^* \}}{1+M}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:msubsup><mml:mi>p</mml:mi><mml:mi>r</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mi>I</mml:mi><mml:mo stretchy="false" form="prefix">{</mml:mo><mml:msubsup><mml:mi>t</mml:mi><mml:mrow><mml:mi>r</mml:mi><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mi>*</mml:mi><mml:mo>*</mml:mo></mml:mrow></mml:msubsup><mml:mo>≥</mml:mo><mml:msubsup><mml:mi>t</mml:mi><mml:mi>r</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:mo stretchy="false" form="postfix">}</mml:mo></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mi>M</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:math></alternatives></inline-formula>.
      Let <inline-formula><alternatives><tex-math><![CDATA[p_{adj} = \frac{1 + I\{ p^{* }_{rm} \geq p_{r} \}}{1+M}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mi>d</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mi>I</mml:mi><mml:mo stretchy="false" form="prefix">{</mml:mo><mml:msubsup><mml:mi>p</mml:mi><mml:mrow><mml:mi>r</mml:mi><mml:mi>m</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msubsup><mml:mo>≥</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false" form="postfix">}</mml:mo></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mi>M</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:math></alternatives></inline-formula></p>
        </sec>
      </sec>
    </sec>
    <sec id="testing-groups">
      <title>Testing Groups</title>
      <p>We assume we have an additional binary variable
  <inline-formula><alternatives><tex-math><![CDATA[G_{i}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mi>G</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
  indicating group member ship with <inline-formula><alternatives><tex-math><![CDATA[\{ (X_{i}, W_{i}, Y_{i}, G_{i}, Z_{i}, D_{i}) \}_{i=1}^n \sim \mathbf{P}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mo stretchy="false" form="prefix">{</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>W</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>G</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>Z</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>D</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:msubsup><mml:mo stretchy="false" form="postfix">}</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:mo>∼</mml:mo><mml:mi>𝐏</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>.</p>
      <p><bold>Definition</bold> (Group Welfare Improvability) Fix a class
  of algorithms <inline-formula><alternatives><tex-math><![CDATA[\mathcal{A}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>𝒜</mml:mi></mml:math></alternatives></inline-formula>
  and a tuple <inline-formula><alternatives><tex-math><![CDATA[(\delta_{g_{1}}, \delta_{g_{2}}) \in \mathbb{R}_{+}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>δ</mml:mi><mml:msub><mml:mi>g</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>δ</mml:mi><mml:msub><mml:mi>g</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>∈</mml:mo><mml:msub><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>.
  We say the algorithm <inline-formula><alternatives><tex-math><![CDATA[a_{0}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mi>a</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:math></alternatives></inline-formula>
  constitutes a <inline-formula><alternatives><tex-math><![CDATA[(\delta_{g_{1}}, \delta_{g_{2}})]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>δ</mml:mi><mml:msub><mml:mi>g</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>δ</mml:mi><mml:msub><mml:mi>g</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>-improvable
  within class <inline-formula><alternatives><tex-math><![CDATA[\mathcal{A}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>𝒜</mml:mi></mml:math></alternatives></inline-formula>
  if there exists an algorithm <inline-formula><alternatives><tex-math><![CDATA[a_{1} \in \mathcal{A}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>∈</mml:mo><mml:mi>𝒜</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
  such that <disp-formula><alternatives><tex-math><![CDATA[
  \frac{V_{g_{1}}(a_{1})}{V_{g_{1}}(a_{0})} \geq 1+\delta_{1} \text{   and   } \frac{V_{g_{2}}(a_{1})}{V_{}{g_{2}}(a_{0})} \geq 1+\delta_{2}
  ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>V</mml:mi><mml:msub><mml:mi>g</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mi>V</mml:mi><mml:msub><mml:mi>g</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:mfrac><mml:mo>≥</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:msub><mml:mi>δ</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mrow><mml:mspace width="0.333em"/><mml:mtext mathvariant="normal"> and </mml:mtext><mml:mspace width="0.333em"/></mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>V</mml:mi><mml:msub><mml:mi>g</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mi>V</mml:mi><mml:mrow/></mml:msub><mml:msub><mml:mi>g</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:mfrac><mml:mo>≥</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:msub><mml:mi>δ</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></alternatives></disp-formula>
  We make adjustments for multiple testing.</p>
    </sec>
    <sec id="main-results">
      <title>Main Results</title>
      <sec id="assumption">
        <title>Assumption</title>
        <p>A1: Independently and Identically Distributed Data The
    observations <inline-formula><alternatives><tex-math><![CDATA[\{ (X_{i}, Y_{i}, W_{i}, Z_{i}) \}_{i=1}^n]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mo stretchy="false" form="prefix">{</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>W</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>Z</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:msubsup><mml:mo stretchy="false" form="postfix">}</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula>
    are independent and identically distributed, random vectors or
    scalars</p>
        <p>A2: Bounded and Measurable Treatment Policies - The treatment
    policies <inline-formula><alternatives><tex-math><![CDATA[a_{0}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mi>a</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:math></alternatives></inline-formula>
    and <inline-formula><alternatives><tex-math><![CDATA[a_{1}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></alternatives></inline-formula>
    and reasurable functions satisfying <inline-formula><alternatives><tex-math><![CDATA[0 \leq a_{j}(X) \leq 1]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mn>0</mml:mn><mml:mo>≤</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>≤</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></alternatives></inline-formula>
    for all <inline-formula><alternatives><tex-math><![CDATA[X]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>X</mml:mi></mml:math></alternatives></inline-formula>
    and <inline-formula><alternatives><tex-math><![CDATA[j = 0, 1]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></alternatives></inline-formula>.
    - The difference <inline-formula><alternatives><tex-math><![CDATA[\delta {a}(X) = a_{1}(X) - a_{0}(X)]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>δ</mml:mi><mml:mi>a</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
    is uniformly bounded implying there exists an
    <inline-formula><alternatives><tex-math><![CDATA[M < \infty]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>M</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>∞</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
    such that <inline-formula><alternatives><tex-math><![CDATA[\mid \delta a(X) \mid \leq M]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>∣</mml:mi><mml:mi>δ</mml:mi><mml:mi>a</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mi>∣</mml:mi><mml:mo>≤</mml:mo><mml:mi>M</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
    for all <inline-formula><alternatives><tex-math><![CDATA[X]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>X</mml:mi></mml:math></alternatives></inline-formula>.</p>
        <p>A3: Finite Second Moments - The conditional treatment effect
    <inline-formula><alternatives><tex-math><![CDATA[t_{0}(X) = \mathbb{E}[Y(1) - Y(0) \mid X]]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>𝔼</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>Y</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mi>Y</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>∣</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
    satisfies <inline-formula><alternatives><tex-math><![CDATA[\mathbb{E}[\tau_{0}^2] < \infty]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>𝔼</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:msubsup><mml:mi>τ</mml:mi><mml:mn>0</mml:mn><mml:mn>2</mml:mn></mml:msubsup><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mo>&lt;</mml:mo><mml:mi>∞</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
    - The product <inline-formula><alternatives><tex-math><![CDATA[\delta a(X)\tau(X)]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>δ</mml:mi><mml:mi>a</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mi>τ</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
    has finite variance: <inline-formula><alternatives><tex-math><![CDATA[\mathbb{E}[\{ \delta a(X) \tau_{0}(X)\}^2] < \infty]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>𝔼</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mo stretchy="false" form="prefix">{</mml:mo><mml:mi>δ</mml:mi><mml:mi>a</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:msub><mml:mi>τ</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:msup><mml:mo stretchy="false" form="postfix">}</mml:mo><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mo>&lt;</mml:mo><mml:mi>∞</mml:mi></mml:mrow></mml:math></alternatives></inline-formula></p>
        <p>A4: Consistent Estimation of Treatment Effects The estimated
    treatment effects <disp-formula><alternatives><tex-math><![CDATA[\hat{\Gamma}_{i} = \tau_{0}(X_{i}) + \epsilon _{i}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:msub><mml:mover><mml:mi>Γ</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>τ</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:msub><mml:mi>ϵ</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></alternatives></disp-formula>
    where the estimation errors <inline-formula><alternatives><tex-math><![CDATA[\epsilon _{i}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mi>ϵ</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
    satisfy - <inline-formula><alternatives><tex-math><![CDATA[\mathbb{E}[\epsilon _{i} \mid X_{i}] = 0]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>𝔼</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:msub><mml:mi>ϵ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∣</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></alternatives></inline-formula>
    - <inline-formula><alternatives><tex-math><![CDATA[\epsilon _{i}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mi>ϵ</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
    is independent of <inline-formula><alternatives><tex-math><![CDATA[X_{i}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
    due to cross-fitting - <inline-formula><alternatives><tex-math><![CDATA[\mathbb{E}[\epsilon^2_{i}] \leq Cn^{2\kappa}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>𝔼</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:msubsup><mml:mi>ϵ</mml:mi><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mo>≤</mml:mo><mml:mi>C</mml:mi><mml:msup><mml:mi>n</mml:mi><mml:mrow><mml:mn>2</mml:mn><mml:mi>κ</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></alternatives></inline-formula>
    for some <inline-formula><alternatives><tex-math><![CDATA[\kappa > 0.25]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>κ</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>0.25</mml:mn></mml:mrow></mml:math></alternatives></inline-formula>
    and constant <inline-formula><alternatives><tex-math><![CDATA[C > 0]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>C</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></alternatives></inline-formula></p>
        <p>A5: Cross-Fitting and Independence The estimation of
    <inline-formula><alternatives><tex-math><![CDATA[\hat{\Gamma}_{i}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mover><mml:mi>Γ</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mi>i</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
    is performed using cross-fitting, ensuring that
    <inline-formula><alternatives><tex-math><![CDATA[\hat{\Gamma}_{i}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mover><mml:mi>Γ</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mi>i</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
    is approximately independent of <inline-formula><alternatives><tex-math><![CDATA[(X_{i}, Y_{i}, W_{i}, Z_{i})]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>W</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>Z</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>.</p>
        <p>A6: Regularity Conditions for the Bootstrap - The samples are
    generated by resampling the pairs <inline-formula><alternatives><tex-math><![CDATA[(X_{i}, \hat{\Gamma}_{i})]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mover><mml:mi>Γ</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>
    with replacement - The bootstrap replicates
    <inline-formula><alternatives><tex-math><![CDATA[T^*_{n}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msubsup><mml:mi>T</mml:mi><mml:mi>n</mml:mi><mml:mo>*</mml:mo></mml:msubsup></mml:math></alternatives></inline-formula>
    mimic the sampling variability of <inline-formula><alternatives><tex-math><![CDATA[T_{n}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mi>T</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
    under the null hypothesis</p>
        <p>A7: Lindeberg-Feller Conditions For the sequence
    <inline-formula><alternatives><tex-math><![CDATA[\{ \psi _{i} \}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mo stretchy="false" form="prefix">{</mml:mo><mml:msub><mml:mi>ψ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false" form="postfix">}</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>
    defined by <inline-formula><alternatives><tex-math><![CDATA[\psi _{i} = \delta a(X_{i})\hat{\Gamma}_{i})]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:msub><mml:mi>ψ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>δ</mml:mi><mml:mi>a</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:msub><mml:mover><mml:mi>Γ</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false" form="postfix">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>,
    the Lindeberg condition holds: <disp-formula><alternatives><tex-math><![CDATA[
    \forall \epsilon>0, \frac{1}{n}\sum_{i=1}^n \mathbb{E}[\psi _{i}^2 \mathbb{I}(\mid\psi _{i}\mid > \epsilon \sqrt{ n })] \to 0, \text{   as } n\to \infty
    ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:mo>∀</mml:mo><mml:mi>ϵ</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>n</mml:mi></mml:mfrac><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:mi>𝔼</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:msubsup><mml:mi>ψ</mml:mi><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:mi>𝕀</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>∣</mml:mi><mml:msub><mml:mi>ψ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mi>∣</mml:mi><mml:mo>&gt;</mml:mo><mml:mi>ϵ</mml:mi><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mo>→</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mrow><mml:mspace width="0.333em"/><mml:mtext mathvariant="normal"> as </mml:mtext><mml:mspace width="0.333em"/></mml:mrow><mml:mi>n</mml:mi><mml:mo>→</mml:mo><mml:mi>∞</mml:mi></mml:mrow></mml:math></alternatives></disp-formula></p>
        <p>A8: Non-degeneracy The variance <inline-formula><alternatives><tex-math><![CDATA[\sigma^2 = Var(\psi _{i})>0]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:msup><mml:mi>σ</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>=</mml:mo><mml:mi>V</mml:mi><mml:mi>a</mml:mi><mml:mi>r</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>ψ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></alternatives></inline-formula>.</p>
        <p>As above, we define the test statistic
    <disp-formula><alternatives><tex-math><![CDATA[
    T_{n} = \hat{V}(a_{1}) - \hat{V}(a_{0}) = \frac{1}{n}\sum_{i=1}^n \psi _{i}.
    ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:msub><mml:mi>T</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mover><mml:mi>V</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mover><mml:mi>V</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>n</mml:mi></mml:mfrac><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:msub><mml:mi>ψ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mi>.</mml:mi></mml:mrow></mml:math></alternatives></disp-formula></p>
        <p><bold>Theorem</bold> (Asymptotic Distribution of the Test
    Statistic). Under assumptions A1-A4, A7, and A8, we have
    <disp-formula><alternatives><tex-math><![CDATA[
    \sqrt{n}(T_n - \theta) \xrightarrow{d} N(0, \sigma^2),
    ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mi>θ</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mover><mml:mo>→</mml:mo><mml:mi>d</mml:mi></mml:mover><mml:mi>N</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:msup><mml:mi>σ</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:math></alternatives></disp-formula>
    where <inline-formula><alternatives><tex-math><![CDATA[\sigma^2 = Var(\psi _{i})]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:msup><mml:mi>σ</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>=</mml:mo><mml:mi>V</mml:mi><mml:mi>a</mml:mi><mml:mi>r</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>ψ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>.</p>
        <p><bold>Proof</bold> By A4 and the law of iterated expectations:
    <disp-formula><alternatives><tex-math><![CDATA[
    \mathbb{E}[\delta a(X_{i})\epsilon _{i}] = \mathbb{E}[\delta a(X_{i})\mathbb{E}[\epsilon _{i}\mid X_{i}]] = 0.
    ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:mi>𝔼</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>δ</mml:mi><mml:mi>a</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:msub><mml:mi>ϵ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>𝔼</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mi>δ</mml:mi><mml:mi>a</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mi>𝔼</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:msub><mml:mi>ϵ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∣</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mi>.</mml:mi></mml:mrow></mml:math></alternatives></disp-formula>
    Since <inline-formula><alternatives><tex-math><![CDATA[\epsilon _{i}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mi>ϵ</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
    and <inline-formula><alternatives><tex-math><![CDATA[X_{i}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
    are independent (due to cross-fitting), and
    <inline-formula><alternatives><tex-math><![CDATA[\mathbb{E}[\epsilon _{i} \mid X_{i}] = 0]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>𝔼</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:msub><mml:mi>ϵ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∣</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></alternatives></inline-formula>,
    we have <disp-formula><alternatives><tex-math><![CDATA[
    Var(\psi _{i}) = Var(\delta a(X_{i})\tau_{0}(X_{i})) + Var(\delta a(X_{i}\epsilon _{i})).
    ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:mi>V</mml:mi><mml:mi>a</mml:mi><mml:mi>r</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>ψ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>V</mml:mi><mml:mi>a</mml:mi><mml:mi>r</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>δ</mml:mi><mml:mi>a</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:msub><mml:mi>τ</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>V</mml:mi><mml:mi>a</mml:mi><mml:mi>r</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>δ</mml:mi><mml:mi>a</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>ϵ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mi>.</mml:mi></mml:mrow></mml:math></alternatives></disp-formula>
    By A4, <inline-formula><alternatives><tex-math><![CDATA[Var(\delta a(X_{i}\epsilon _{i}))]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>V</mml:mi><mml:mi>a</mml:mi><mml:mi>r</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mi>δ</mml:mi><mml:mi>a</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>ϵ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
    is <inline-formula><alternatives><tex-math><![CDATA[O(n^{-2\kappa})]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>O</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msup><mml:mi>n</mml:mi><mml:mrow><mml:mi>−</mml:mi><mml:mn>2</mml:mn><mml:mi>κ</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>.</p>
        <p>Finally, under assumptions A1, A2, A3, A7, and A8, the
    Lindeberg-Feller CLT applies to <inline-formula><alternatives><tex-math><![CDATA[\{ \psi _{i} \}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mo stretchy="false" form="prefix">{</mml:mo><mml:msub><mml:mi>ψ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false" form="postfix">}</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>,
    yielding <disp-formula><alternatives><tex-math><![CDATA[
    \sqrt{ n }(T_{n} - \theta) \xrightarrow{d} N(0, \sigma^2).
    ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mi>θ</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mover><mml:mo>→</mml:mo><mml:mi>d</mml:mi></mml:mover><mml:mi>N</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:msup><mml:mi>σ</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mi>.</mml:mi></mml:mrow></mml:math></alternatives></disp-formula></p>
        <p>Furthermore, for the term involving
    <inline-formula><alternatives><tex-math><![CDATA[\epsilon _{i}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mi>ϵ</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></alternatives></inline-formula>:
    <disp-formula><alternatives><tex-math><![CDATA[
    \frac{1}{n}\sum_{i=1}^n \delta a(X_{i})\epsilon _{i} = O_{p}\left( \frac{1}{n^{\kappa-0.5}} \right) = o_{p}\left( \frac{1}{\sqrt{ n }} \right)
    ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mi>n</mml:mi></mml:mfrac><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:mi>δ</mml:mi><mml:mi>a</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:msub><mml:mi>ϵ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>O</mml:mi><mml:mi>p</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:msup><mml:mi>n</mml:mi><mml:mrow><mml:mi>κ</mml:mi><mml:mo>−</mml:mo><mml:mn>0.5</mml:mn></mml:mrow></mml:msup></mml:mfrac><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mi>o</mml:mi><mml:mi>p</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt></mml:mfrac><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></disp-formula>
    END PROOF</p>
        <p><bold>Theorem</bold> (Consistency of Bootstrap) Under Assumptions
    A1-A8, the bootstrap p-value <inline-formula><alternatives><tex-math><![CDATA[\hat{p}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mover><mml:mi>p</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover></mml:math></alternatives></inline-formula>
    for testing the null hypothesis <disp-formula><alternatives><tex-math><![CDATA[
    H_{0}: V(a_{1}) \leq V(a_{0})
    ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:msub><mml:mi>H</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>:</mml:mo><mml:mi>V</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>≤</mml:mo><mml:mi>V</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></disp-formula>
    using test statistic <inline-formula><alternatives><tex-math><![CDATA[T_{n}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mi>T</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
    converges in probability to the true p-value
    <inline-formula><alternatives><tex-math><![CDATA[p]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>p</mml:mi></mml:math></alternatives></inline-formula>
    as <inline-formula><alternatives><tex-math><![CDATA[n \to \infty]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>n</mml:mi><mml:mo>→</mml:mo><mml:mi>∞</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>.
    That is <disp-formula><alternatives><tex-math><![CDATA[
    \hat{p} \to p,
    ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:mover><mml:mi>p</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mo>→</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo></mml:mrow></mml:math></alternatives></disp-formula>
    where <inline-formula><alternatives><tex-math><![CDATA[p = \mathbb{P}(\sqrt{ n }(T_{n} - \theta) \geq (T^{obs}_{n} - \theta))]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>p</mml:mi><mml:mo>=</mml:mo><mml:mi>ℙ</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mi>θ</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>≥</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msubsup><mml:mi>T</mml:mi><mml:mi>n</mml:mi><mml:mrow><mml:mi>o</mml:mi><mml:mi>b</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msubsup><mml:mo>−</mml:mo><mml:mi>θ</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
    with <inline-formula><alternatives><tex-math><![CDATA[\theta = V(a_{1}) - V(a_{0})]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>θ</mml:mi><mml:mo>=</mml:mo><mml:mi>V</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mi>V</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>.</p>
        <p>Proof Define the bootstrap test statistic as
    <disp-formula><alternatives><tex-math><![CDATA[
    T^*_{n} = \frac{1}{n} \sum_{i=1}^n \psi _{i}^*, \text{   where } \psi^*_{i} = \delta a(X_{i}^*)\hat{\Gamma}_{i}^*.
    ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:msubsup><mml:mi>T</mml:mi><mml:mi>n</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>n</mml:mi></mml:mfrac><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:msubsup><mml:mi>ψ</mml:mi><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:mo>,</mml:mo><mml:mrow><mml:mspace width="0.333em"/><mml:mtext mathvariant="normal"> where </mml:mtext><mml:mspace width="0.333em"/></mml:mrow><mml:msubsup><mml:mi>ψ</mml:mi><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:mi>δ</mml:mi><mml:mi>a</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msubsup><mml:mi>X</mml:mi><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:msubsup><mml:mover><mml:mi>Γ</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:mi>.</mml:mi></mml:mrow></mml:math></alternatives></disp-formula></p>
        <p>Our first want to show that, conditional on the observed data:
    <disp-formula><alternatives><tex-math><![CDATA[
    \sqrt{ n }(T^*_{n} - T_{n}) \xrightarrow{d} N(0, \hat{\sigma}^2),
    ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msubsup><mml:mi>T</mml:mi><mml:mi>n</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:mo>−</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mover><mml:mo>→</mml:mo><mml:mi>d</mml:mi></mml:mover><mml:mi>N</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:msup><mml:mover><mml:mi>σ</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:math></alternatives></disp-formula>
    where <inline-formula><alternatives><tex-math><![CDATA[\hat{\sigma}^2 = \frac{1}{n} \sum_{i=1}^n (\psi _{i} - \bar{\psi})^2]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:msup><mml:mover><mml:mi>σ</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mn>2</mml:mn></mml:msup><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>n</mml:mi></mml:mfrac><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:msup><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>ψ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mover><mml:mi>ψ</mml:mi><mml:mo accent="true">‾</mml:mo></mml:mover><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:math></alternatives></inline-formula>
    and <inline-formula><alternatives><tex-math><![CDATA[\bar{\psi} = \frac{1}{n}\sum_{i=1}^n \psi _{i}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mover><mml:mi>ψ</mml:mi><mml:mo accent="true">‾</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>n</mml:mi></mml:mfrac><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:msub><mml:mi>ψ</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>.</p>
        <p>Given the data, the bootstrap sample
    <inline-formula><alternatives><tex-math><![CDATA[\{ \psi _{i}^* \}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mo stretchy="false" form="prefix">{</mml:mo><mml:msubsup><mml:mi>ψ</mml:mi><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:mo stretchy="false" form="postfix">}</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>
    consists of i.i.d. draws from the empirical distribution of
    <inline-formula><alternatives><tex-math><![CDATA[\{ \psi _{i} \}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mo stretchy="false" form="prefix">{</mml:mo><mml:msub><mml:mi>ψ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false" form="postfix">}</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>.
    Conditional on the data, the bootstrap sample satisfies the
    Lindeberg condition (since the original sample does). Therefore,
    <disp-formula><alternatives><tex-math><![CDATA[
    \sqrt{ n }(T^*_{n} - T_{n}) \mid \text{data} \xrightarrow{d} N(0, \hat{\sigma}^2).
    ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msubsup><mml:mi>T</mml:mi><mml:mi>n</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:mo>−</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>∣</mml:mo><mml:mtext mathvariant="normal">data</mml:mtext><mml:mover><mml:mo>→</mml:mo><mml:mi>d</mml:mi></mml:mover><mml:mi>N</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:msup><mml:mover><mml:mi>σ</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mi>.</mml:mi></mml:mrow></mml:math></alternatives></disp-formula></p>
        <p>Furthermore, under A2 and A3, <inline-formula><alternatives><tex-math><![CDATA[\hat{\sigma}^2 \xrightarrow{p} \sigma^2]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:msup><mml:mover><mml:mi>σ</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mn>2</mml:mn></mml:msup><mml:mover><mml:mo>→</mml:mo><mml:mi>p</mml:mi></mml:mover><mml:msup><mml:mi>σ</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:math></alternatives></inline-formula>.</p>
        <p>Combining the above, the bootstrap distribution of
    <inline-formula><alternatives><tex-math><![CDATA[\sqrt{ n }(T^*_{n} - T_{n})]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msubsup><mml:mi>T</mml:mi><mml:mi>n</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:mo>−</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>
    converges in distribution (conditional on the data) to the same
    normal distribution as <inline-formula><alternatives><tex-math><![CDATA[\sqrt{ n }(T_{n}-\theta)]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mi>θ</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>.</p>
        <p>We now turn to showing convergence of the bootstrap p-value. We
    defined the p-value as <disp-formula><alternatives><tex-math><![CDATA[
    \hat{p} = \mathbb{P}^*(\sqrt{ n }(T^*_{n} - T_{n}) \geq \sqrt{ n }(T_{n}-\theta) \mid \text{data}),
    ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:mover><mml:mi>p</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:msup><mml:mi>ℙ</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msubsup><mml:mi>T</mml:mi><mml:mi>n</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:mo>−</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>≥</mml:mo><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mi>θ</mml:mi><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>∣</mml:mo><mml:mtext mathvariant="normal">data</mml:mtext><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:math></alternatives></disp-formula>
    where <inline-formula><alternatives><tex-math><![CDATA[\mathbb{P^*}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msup><mml:mi>ℙ</mml:mi><mml:mo mathvariant="double-struck">*</mml:mo></mml:msup></mml:math></alternatives></inline-formula>
    denotes the probability under the bootstrap distribution.</p>
      </sec>
    </sec>
    <sec id="technical-considerations">
      <title>Technical Considerations</title>
      <p>Super Learning / Ensemble learning - convex approach and best
  learner. - Use a mix of traditional methods with known convergence
  rates, as well as LM methods</p>
    </sec>
    <sec id="simulations">
      <title>Simulations</title>
      <p>We consider the following DGPs ### Linear DGP with Simple Threshold
  Decision Rules</p>
      <p>We first consider a single variable distributed uniformly on 0 and
  1, where our two algorithms are simple threshold decision rules
  <disp-formula><alternatives><tex-math><![CDATA[
  X \sim \text{Uniform}[0, 1].
  ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:mi>X</mml:mi><mml:mo>∼</mml:mo><mml:mtext mathvariant="normal">Uniform</mml:mtext><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow><mml:mi>.</mml:mi></mml:mrow></mml:math></alternatives></disp-formula>
  The true utility utility is given by <inline-formula><alternatives><tex-math><![CDATA[u_{i} = \beta X_{i}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>β</mml:mi><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>.
  We assume our DDML estimates are unbiased and given by
  <disp-formula><alternatives><tex-math><![CDATA[
  \hat{u}_{i} = u_{i} + e_{i}, \text{ where } e_{i} \sim \text{N}(0, \sigma^2).
  ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mrow><mml:msub><mml:mover><mml:mi>u</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>e</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mrow><mml:mspace width="0.333em"/><mml:mtext mathvariant="normal"> where </mml:mtext><mml:mspace width="0.333em"/></mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∼</mml:mo><mml:mtext mathvariant="normal">N</mml:mtext><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:msup><mml:mi>σ</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mi>.</mml:mi></mml:mrow></mml:math></alternatives></disp-formula></p>
      <p>The decision rules are given by <disp-formula><alternatives><tex-math><![CDATA[
  \begin{aligned}
  a_{1}(X_{i})= \begin{cases} 
  1  & \text{if } X_{i} > c_{1} \\
  0  & \text{ otherwise}
  \end{cases} \\
  a_{2}(X_{i})= \begin{cases} 
  1  & \text{if } X_{i} > c_{2} \\
  0  & \text{ otherwise}
  \end{cases}
  \end{aligned}
  ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mtable><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">{</mml:mo><mml:mtable><mml:mtr><mml:mtd columnalign="left" style="text-align: left"><mml:mn>1</mml:mn></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mrow><mml:mtext mathvariant="normal">if </mml:mtext><mml:mspace width="0.333em"/></mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>&gt;</mml:mo><mml:msub><mml:mi>c</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left" style="text-align: left"><mml:mn>0</mml:mn></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mrow><mml:mspace width="0.333em"/><mml:mtext mathvariant="normal"> otherwise</mml:mtext></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:msub><mml:mi>a</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">{</mml:mo><mml:mtable><mml:mtr><mml:mtd columnalign="left" style="text-align: left"><mml:mn>1</mml:mn></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mrow><mml:mtext mathvariant="normal">if </mml:mtext><mml:mspace width="0.333em"/></mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>&gt;</mml:mo><mml:msub><mml:mi>c</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left" style="text-align: left"><mml:mn>0</mml:mn></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mrow><mml:mspace width="0.333em"/><mml:mtext mathvariant="normal"> otherwise</mml:mtext></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula>
  We control the true difference in algorithm welfare
  (<inline-formula><alternatives><tex-math><![CDATA[V(a_{1}) - V(a_{2})]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mi>V</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mi>V</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>)
  by adjusting <inline-formula><alternatives><tex-math><![CDATA[c_{1}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mi>c</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></alternatives></inline-formula>
  and <inline-formula><alternatives><tex-math><![CDATA[c_{2}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mi>c</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:math></alternatives></inline-formula>.
  We also control estimation variance <inline-formula><alternatives><tex-math><![CDATA[\hat{u}_{i}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msub><mml:mover><mml:mi>u</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mi>i</mml:mi></mml:msub></mml:math></alternatives></inline-formula>
  by changing <inline-formula><alternatives><tex-math><![CDATA[\sigma^2]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:msup><mml:mi>σ</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:math></alternatives></inline-formula>.</p>
      <p>The expected utility is given by <disp-formula><alternatives><tex-math><![CDATA[
  \begin{aligned}
  V(a_{1})- V(a_{2}) &= \int _{c_{1}}^1 \beta X_{i} \, dX_{i} - \int _{c_{2}}^1 \beta X_{i} \, dX_{i}  \\
  &= \frac{\beta}{2}(c_{2}^2 - c_{1}^2)
  \end{aligned}
  ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mtable><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:mi>V</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mi>V</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mo>=</mml:mo><mml:msubsup><mml:mo>∫</mml:mo><mml:msub><mml:mi>c</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mn>1</mml:mn></mml:msubsup><mml:mi>β</mml:mi><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mspace width="0.167em"/><mml:mi>d</mml:mi><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msubsup><mml:mo>∫</mml:mo><mml:msub><mml:mi>c</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mn>1</mml:mn></mml:msubsup><mml:mi>β</mml:mi><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mspace width="0.167em"/><mml:mi>d</mml:mi><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right" style="text-align: right"/><mml:mtd columnalign="left" style="text-align: left"><mml:mo>=</mml:mo><mml:mfrac><mml:mi>β</mml:mi><mml:mn>2</mml:mn></mml:mfrac><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msubsup><mml:mi>c</mml:mi><mml:mn>2</mml:mn><mml:mn>2</mml:mn></mml:msubsup><mml:mo>−</mml:mo><mml:msubsup><mml:mi>c</mml:mi><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:msubsup><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
      <sec id="nonlinear-dgp-with-quadratic-decision-rules">
        <title>Nonlinear DGP with Quadratic Decision Rules</title>
        <p>We next use the following DGP <disp-formula><alternatives><tex-math><![CDATA[
    \begin{aligned}
    X_{i} &\sim \text{Uniform}[0,1] \\
    u_{i} &= \gamma X_{i}^2,  \\
    \hat{u}_{i} &= u_{i} + e_{i}, \text{where } e_{i} \sim \text{N}(0, \sigma^2)
    \end{aligned}
    ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mtable><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mo>∼</mml:mo><mml:mtext mathvariant="normal">Uniform</mml:mtext><mml:mrow><mml:mo stretchy="true" form="prefix">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="true" form="postfix">]</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:msub><mml:mi>u</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mo>=</mml:mo><mml:mi>γ</mml:mi><mml:msubsup><mml:mi>X</mml:mi><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:mo>,</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:msub><mml:mover><mml:mi>u</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mi>i</mml:mi></mml:msub></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mo>=</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>e</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mrow><mml:mtext mathvariant="normal">where </mml:mtext><mml:mspace width="0.333em"/></mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∼</mml:mo><mml:mtext mathvariant="normal">N</mml:mtext><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:msup><mml:mi>σ</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
        <p>The decision algorithms are again threshold rules
    <disp-formula><alternatives><tex-math><![CDATA[
    \begin{aligned}
    a_{1}(X_{i})= \begin{cases} 
    1  & \text{if } X^2_{i} > c_{1} \\
    0  & \text{ otherwise}
    \end{cases} \\
    a_{2}(X_{i})= \begin{cases} 
    1  & \text{if } X^2_{i} > c_{2} \\
    0  & \text{ otherwise}
    \end{cases}
    \end{aligned}
    ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mtable><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">{</mml:mo><mml:mtable><mml:mtr><mml:mtd columnalign="left" style="text-align: left"><mml:mn>1</mml:mn></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mrow><mml:mtext mathvariant="normal">if </mml:mtext><mml:mspace width="0.333em"/></mml:mrow><mml:msubsup><mml:mi>X</mml:mi><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:mo>&gt;</mml:mo><mml:msub><mml:mi>c</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left" style="text-align: left"><mml:mn>0</mml:mn></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mrow><mml:mspace width="0.333em"/><mml:mtext mathvariant="normal"> otherwise</mml:mtext></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:msub><mml:mi>a</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true" form="prefix">{</mml:mo><mml:mtable><mml:mtr><mml:mtd columnalign="left" style="text-align: left"><mml:mn>1</mml:mn></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mrow><mml:mtext mathvariant="normal">if </mml:mtext><mml:mspace width="0.333em"/></mml:mrow><mml:msubsup><mml:mi>X</mml:mi><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:mo>&gt;</mml:mo><mml:msub><mml:mi>c</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left" style="text-align: left"><mml:mn>0</mml:mn></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mrow><mml:mspace width="0.333em"/><mml:mtext mathvariant="normal"> otherwise</mml:mtext></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
        <p>The expected difference in utility between the two algorithms is
    <disp-formula><alternatives><tex-math><![CDATA[
    \begin{aligned}
    V(a_{1})- V(a_{2}) &= \int _{c_{1}}^1 \gamma X_{i} \, dX^2_{i} - \int _{c_{2}}^1 \gamma X^2_{i} \, dX_{i}  \\
    &= \frac{\gamma}{3}(c_{2}^{3/2} - c_{1}^{3/2})
    \end{aligned}
    ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mtable><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:mi>V</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mi>V</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mo>=</mml:mo><mml:msubsup><mml:mo>∫</mml:mo><mml:msub><mml:mi>c</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mn>1</mml:mn></mml:msubsup><mml:mi>γ</mml:mi><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mspace width="0.167em"/><mml:mi>d</mml:mi><mml:msubsup><mml:mi>X</mml:mi><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:mo>−</mml:mo><mml:msubsup><mml:mo>∫</mml:mo><mml:msub><mml:mi>c</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mn>1</mml:mn></mml:msubsup><mml:mi>γ</mml:mi><mml:msubsup><mml:mi>X</mml:mi><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:mspace width="0.167em"/><mml:mi>d</mml:mi><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right" style="text-align: right"/><mml:mtd columnalign="left" style="text-align: left"><mml:mo>=</mml:mo><mml:mfrac><mml:mi>γ</mml:mi><mml:mn>3</mml:mn></mml:mfrac><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msubsup><mml:mi>c</mml:mi><mml:mn>2</mml:mn><mml:mrow><mml:mn>3</mml:mn><mml:mi>/</mml:mi><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:mo>−</mml:mo><mml:msubsup><mml:mi>c</mml:mi><mml:mn>1</mml:mn><mml:mrow><mml:mn>3</mml:mn><mml:mi>/</mml:mi><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
      </sec>
      <sec id="binary-outcome-dgp-with-logistic-decision-rules">
        <title>Binary Outcome DGP with Logistic Decision Rules</title>
        <p>• <bold>Independent Variable:</bold> 
    <inline-formula><alternatives><tex-math><![CDATA[X_i \sim \text{Normal}(0, 1)]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∼</mml:mo><mml:mtext mathvariant="normal">Normal</mml:mtext><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula></p>
        <p>• <bold>True Utility:</bold>  <inline-formula><alternatives><tex-math><![CDATA[u_i = \delta \cdot \mathbb{I}(Y_i = 1) , where  Y_i \sim \text{Bernoulli}(p_i)  and  p_i = \frac{1}{1 + e^{-\theta X_i}}]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>δ</mml:mi><mml:mo>⋅</mml:mo><mml:mi>𝕀</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mi>w</mml:mi><mml:mi>h</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>Y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∼</mml:mo><mml:mtext mathvariant="normal">Bernoulli</mml:mtext><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mi>d</mml:mi><mml:msub><mml:mi>p</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mi>−</mml:mi><mml:mi>θ</mml:mi><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:mfrac></mml:mrow></mml:math></alternatives></inline-formula></p>
        <p>• <bold>Estimated Utility:</bold>  <inline-formula><alternatives><tex-math><![CDATA[\hat{u}_i = u_i + \varepsilon_i]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:msub><mml:mover><mml:mi>u</mml:mi><mml:mo accent="true">̂</mml:mo></mml:mover><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>ε</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></alternatives></inline-formula></p>
        <p>The expected difference in utility between the two algorithms is
    <disp-formula><alternatives><tex-math><![CDATA[
    \begin{aligned}
    V(a_{1})- V(a_{2}) &= \int_{c_{1}}^\infty \frac{\delta  e^{-\frac{{X_i}^2}{2}}}{\sqrt{2 \pi } \left(e^{-\theta X_{i}}+1\right)}\, dX_{i} - \int_{c_{2}}^\infty \frac{\delta  e^{-\frac{{X_i}^2}{2}}}{\sqrt{2 \pi } \left(e^{-\theta X_{i}}+1\right)}\, dX_{i} 
    \end{aligned}
    ]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="block"><mml:mtable><mml:mtr><mml:mtd columnalign="right" style="text-align: right"><mml:mi>V</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mi>V</mml:mi><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left" style="text-align: left"><mml:mo>=</mml:mo><mml:msubsup><mml:mo>∫</mml:mo><mml:msub><mml:mi>c</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mi>∞</mml:mi></mml:msubsup><mml:mfrac><mml:mrow><mml:mi>δ</mml:mi><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mi>−</mml:mi><mml:mfrac><mml:msup><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mn>2</mml:mn></mml:msup><mml:mn>2</mml:mn></mml:mfrac></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:msqrt><mml:mrow><mml:mn>2</mml:mn><mml:mi>π</mml:mi></mml:mrow></mml:msqrt><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mi>−</mml:mi><mml:mi>θ</mml:mi><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msup><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:mfrac><mml:mspace width="0.167em"/><mml:mi>d</mml:mi><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msubsup><mml:mo>∫</mml:mo><mml:msub><mml:mi>c</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mi>∞</mml:mi></mml:msubsup><mml:mfrac><mml:mrow><mml:mi>δ</mml:mi><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mi>−</mml:mi><mml:mfrac><mml:msup><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mn>2</mml:mn></mml:msup><mml:mn>2</mml:mn></mml:mfrac></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:msqrt><mml:mrow><mml:mn>2</mml:mn><mml:mi>π</mml:mi></mml:mrow></mml:msqrt><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mi>−</mml:mi><mml:mi>θ</mml:mi><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msup><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:mrow></mml:mfrac><mml:mspace width="0.167em"/><mml:mi>d</mml:mi><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
      </sec>
    </sec>
    <sec id="empirical-application">
      <title>Empirical Application</title>
      <p>In our first empirical example, we utilise data from the randomised
  controlled trial (RCT) conducted by Finkelstein et al. (2020) on the
  Camden Coalition of Healthcare Providers’ “hotspotting” program. The
  program targeted “superutilizers”—patients with exceptionally high
  healthcare usage—and aimed to reduce hospital readmission rates by
  employing a care-transition model involving multidisciplinary teams of
  nurses, social workers, and community health workers. The intervention
  group consisted of 800 hospitalised patients with medically and
  socially complex conditions, all of whom had experienced at least one
  additional hospitalisation in the preceding six months.</p>
      <p>The critical variables in the study include hospital readmission
  within 180 days and the costs associated with readmission and other
  health-related expenditures. The data collected included patient
  demographics, hospitalisation history, and post-discharge interactions
  with care teams. You can see a complete list of variables used in the
  appendix below. Despite the widespread optimism surrounding
  hotspotting, the RCT results indicated no significant difference in
  average treatment effect of readmission rates between the intervention
  and control groups, challenging prior observational claims of the
  program’s efficacy.</p>
      <p>We apply this data to evaluate the impact of algorithmic
  decision-making in healthcare settings. Specifically, we investigate
  heterogeneity in treatment effects and compare two automated
  algorithms in their ability to identify high-risk patients who could
  benefit most from targeted interventions.</p>
      <p>We find substantial variation in the treatment effects estimated
  through double machine learning. Further, sensitivity tests are
  performed in the appendix.</p>
    </sec>
    <sec id="conclusion">
      <title>Conclusion</title>
    </sec>
    <sec id="alternative---split-sample">
      <title>Alternative - Split Sample</title>
      <p>We consider the training set <inline-formula><alternatives><tex-math><![CDATA[\{ X_{i}, Y_{i} \}_{i=1}^n]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mo stretchy="false" form="prefix">{</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msubsup><mml:mo stretchy="false" form="postfix">}</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula>
  and a test point <inline-formula><alternatives><tex-math><![CDATA[(X_{n+1}, Y_{n+1})]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mrow><mml:mo stretchy="true" form="prefix">(</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="true" form="postfix">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>
  sampled i.i.d. from some unknown distribution
  <inline-formula><alternatives><tex-math><![CDATA[P]]></tex-math><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" display="inline"><mml:mi>P</mml:mi></mml:math></alternatives></inline-formula>.</p>
    </sec>
  </body>
  <back>
</back>
</article>
